# [===] THE LIBRARIES [===] #
from flask import Flask, redirect, url_for, render_template, request, session  # IMPORTING ALL NECESSARY LIBRARIES TO BE USED
from datetime import timedelta
import sqlite3
import re
import smtplib
import datetime
from datetime import date
import time

gmail_user = 'REDACTED'       # ALONGSIDE ESTABLISHING THE GMAIL DATA, FOR SMTPLIB WHEN IT COMES TO THE CONTACT PAGE
gmail_password = 'REDACTED'
# [===] [===] #


# [===] THE DATABASE [===] #
db = sqlite3.connect("NewRiceCookerDatabase.db", check_same_thread=False)
cursor = db.cursor()  # CONNECTING THE DATABASE AND CREATING A CURSOR TO PERFORM SQL WITH SQLITE
# [===] [===] #

# [===] FLASK SERVER [===] #
app = Flask(__name__)                                # CREATING THE APP FLASK
app.secret_key = "secretkey"                         # CREATING THE SECRET KEY
app.permanent_session_lifetime = timedelta(days=2)   # ALL SESSION DATA WILL LAST UP TO 2 DAYS UNLESS STATED OTHERWISE
# [===] [===] #

# [===] HOME PAGE [===] #
@app.route("/", methods=["POST", "GET"])            # ENABLES POST AND GET REQUESTS
def HomePage():                                     # SUBROUTINE FOR THE HOMEPAGE
  global DiscountUsed                               # GLOBALISE DISCOUNT USED AND SET IT AS A 0 SO THE SERVER KNOWS THE USER HASN'T USED ANY DISCOUNTS YET
  DiscountUsed = 0
  
  # THE FOLLOWING CODE IS TO GO THROUGH THE TABLE WITH ALL OF THE PRODUCT INFORMATION TO BE ABLE TO PUT IT ON THE FRONTEND

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=1")
  # USING SQL, IT'S POSSIBLE TO GET THE PRODUCT NAME, PRICE AND THE COST OF SHIPPING FOR WHEN PRODUCT ID IS 1
  for x in cursor.fetchall():
    Product1Details = x
  # CONSEQUENTLY, USING A FOR LOOP, WE'RE ABLE TO PUT ALL OF THIS INFORMATION TO VARIABLE PRODUCT1DETAILS FOR THE TIME BEING, AS AN ARRAY

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=2")
  # SQL SELECT STATEMENT ONCE AGAIN TO GET THE PRODUCT NAME, PRICE AND COST OF SHIPPING FOR PRODUCT ID 2
  for x in cursor.fetchall():
    Product2Details = x
  # USING A FOR LOOP TO GO THROUGH ALL OF THE DETAILS OF PRODUCT ID 2 AND PUT IT INTO THE ARRAY PRODUCT2DETAILS

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=3")
  # SQL SELECT STATEMENT TO GET THE PRODUCT NAME, PRICE AND COST OF SHIPPING FOR WHEN PRODUCT ID IS 3
  for x in cursor.fetchall():
    Product3Details = x
  # USING A FOR LOOP TO GO THROUGH ALL OF THE INFORMATION SELECTED AND APPEND IT INTO THE ARRAY PRODUCT3DETAILS

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=4")
  # SQL SELECT STATEMENT TO GET THE PRODUCT NAME, PRICE AND COST OF SHIPPING FOR PRODUCT ID 4
  for x in cursor.fetchall():
    Product4Details = x
  # USING A FOR LOOP TO GO THROUGH ALL OF THE INFORMATION OF PRODUCT ID 4 AND APPEND IT TO THE ARRAY PRODUCT4DETAILS

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=5")
  # SQL SELECT STATEMENT TO GO GET PRODUCT ID 5 NAME, PRICE AND COST OF SHIPPING FROM THE TABLE PRODUCTS
  for x in cursor.fetchall():
    Product5Details = x
  # USING A FOR LOOP TO GO THROUGH ALL OF THE INFORMATION OF PRODUCT ID 5 AND PUT IT INTO THE ARRAY PRODUCT 5 DETAILS FOR LATER USE

  cursor.execute("SELECT ProductName, ProductPrice, ProductShipping FROM tblProducts WHERE ProductID=6")
  # SQL SELECT STATEMENT FOR PRODUCT ID 6 TO GET THEIR NAME, PRICE AND COST OF SHIPPING
  for x in cursor.fetchall():
    Product6Details = x
  # AND THEN USING THE FOR LOOP TO GO THROUGH ALL OF THE INFORMATION OF PRODUCT 6 AND PUT IT INTO THE ARRAY PRODUCT 6 DETAILS

  # CONSEQUENTLY, THE FOLLOWING CODE IS TO GET THE INFORMATION OUT OF THEIR ARRAY FORM, INTO NAME, PRICE AND SHIPPING FOR THE FRONTEND

  ProductName1 = Product1Details[0] # PRODUCT 1 GET IT'S NAME BY GOING THROUGH THE ARRAY AND IT'S FIRST ELEMENT AKA 0
  ProductPrice1 = Product1Details[1] # PRODUCT 1 GET IT'S PRICE BY GOING THROUGH THE ARRAY AND THE 2ND ELEMENT, AKA 1
  if Product1Details[2] == 0: # THIS USING A IF STATEMENT GO THROUGH PRODUCT 1 COST OF SHIPPING, IF IT'S 0, IT'S ASSIGNED AS FREE INSTEAD OF A NUMBER
    ProductShipping1 = "Free"
  else: # ELSE, THAN PRODUCT 1 COST OF SHIPPING SHALL BE ASSIGNED TO IT'S RIGHTFUL INTEGER
    ProductShipping1 = Product1Details[2]
    ProductShipping1 = str(ProductShipping1) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping1 = ("£" + ProductShipping1)

  ProductName2 = Product2Details[0] # THIS IS PRODUCT 2 GETTING ITS NAME FROM THE ARRAY THROUGH INDEXING THE 1ST ELEMENT WHICH IS 0
  ProductPrice2 = Product2Details[1] # THIS IS PRODUCT 2 GETTING ITS PRICE FROM THE ARRAY THROUGH INDEXING THE 2ND ELEMENT WHICH IS 1
  if Product2Details[2] == 0: # THIS IS PRODUCT 2 GETTING IT'S COST OF SHIPPING, IF IT'S EQUAL TO 0 THAN IT'S ASSIGNED AS FREE
    ProductShipping2 = "Free"
  else: # ELSE THAN WE GIVE PRODUCT 2 IT'S RIGHTFUL COST OF SHIPPING NUMBER
    ProductShipping2 = Product2Details[2]
    ProductShipping2 = str(ProductShipping2) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping2 = ("£" + ProductShipping2)

  ProductName3 = Product3Details[0] # THIS IS PRODUCT 3 GETTING ITS NAME FROM THE ARRAY THROUGH INDEXING THE 1ST ELEMENT WHICH IS 0
  ProductPrice3 = Product3Details[1] # THIS IS PRODUCT 3 GETTING ITS PRICE FROM THE ARRAY THROUGH INDEXING THE 2ND ELEMENT WHICH IS 1
  if Product3Details[2] == 0: # THIS IS PRODUCT 3 GETTING ITS COST OF SHIPPING, IF ITS EQUAL TO 0, THAN WE CAN ASSUME IT'S FREE
    ProductShipping3 = "Free"
  else: # ELSE THAN WE GO THROUGH THE ARRAY USING INDEX NUMBER 2 WHICH IS THE 3RD ELEMENT, WHICH IS THE PRODUCT'S COST OF SHIPPING
    ProductShipping3 = Product3Details[2]
    ProductShipping3 = str(ProductShipping3) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping3 = ("£" + ProductShipping3)

  ProductName4 = Product4Details[0] # THIS IS PRODUCT 4 GETTING ITS NAME FROM THE ARRAY THROUGH INDEXING THE 1ST ELEMENT WHICH IS 0
  ProductPrice4 = Product4Details[1] # THIS IS PRODUCT 4 GETTING ITS PRICE FROM THE ARRAY THROUGH INDEXING THE 2ND ELEMENT WHICH IS 1
  if Product4Details[2] == 0: # THIS IS PRODUCT 4 GETTING ITS COST OF SHIPPING, IF THE COST OF SHIPPING IS 0 THAN WE CAN ASSUME ITS FREE
    ProductShipping4 = "Free"
  else: # ELSE THAN THE COST OF SHIPPING FOR PRODUCT 4 IS ASSIGNED THROUGH THE ARRAY BY INDEX 2
    ProductShipping4 = Product4Details[2]
    ProductShipping4 = str(ProductShipping4) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping4 = ("£" + ProductShipping4)

  ProductName5 = Product5Details[0] # THIS IS PRODUCT 5 GETTING ITS NAME FROM THE ARRAY THROUGH INDEXING THE 1ST ELEMENT WHICH IS 0
  ProductPrice5 = Product5Details[1] # THIS IS PRODUCT 5 GETTING ITS PRICE FROM THE ARRAY THROUGH INDEXING THE 2ND ELEMENT WHICH IS 1
  if Product5Details[2] == 0: # THIS IS PRODUCT 5 GETTING ITS COST OF SHIPPING FROM THE ARRAY, IF ITS EQUAL TO 0, WE CAN ASSUME ITS FREE
    ProductShipping5 = "Free"
  else: # ELSE THAN THE COST OF SHIPPING FOR PRODUCT 5 IS ASSIGNED THROUGH THE ARRAY 3RD ELEMENT, WHICH IS INDEX 2
    ProductShipping5 = Product5Details[2]
    ProductShipping5 = str(ProductShipping5) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping5 = ("£" + ProductShipping5)

  ProductName6 = Product6Details[0] # THIS IS PRODUCT 6 GETTING ITS NAME FROM THE ARRAY THROUGH INDEXING THE 1ST ELEMENT WHICH IS 0
  ProductPrice6 = Product6Details[1] # THIS IS PRODUCT 6 GETTING ITS PRICE FROM THE ARRAY THROUGH INDEXING THE 2ND ELEMENT WHICH IS 1
  if Product6Details[2] == 0: # THIS IS PRODUCT 6 COST OF SHIPPING, IF ITS EQUAL TO 0 THAN WE CAN ASSUME ITS FREE
    ProductShipping6 = "Free"
  else: # ELSE THAN THE COST OF SHIPPING FOR PRODUCT 6 IS THE 3RD ELEMENT OF THE ARRAY, WHICH IS INDEX 2
    ProductShipping6 = Product6Details[2]
    ProductShipping6 = str(ProductShipping6) # ALONGSIDE THAN DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED
    ProductShipping6 = ("£" + ProductShipping6)

  # TO BE ABLE TO PUT THE PRODUCT PRICE OF EACH PRODUCTS ONTO THE FRONTEND, WE DATA CAST CONVERT THEIR TYPE INTO A STRING, WHICH SHALL ALLOW US TO HTTP REQUEST THE HOMEPAGE TO THE FRONTEND, WITH THE PRICES OF THE PRODUCTS BY CONCATENATING THE POUND SYMBOL IN FRONT
  ProductPrice1 = str(ProductPrice1)
  ProductPrice1 = ("£" + ProductPrice1)
  ProductPrice2 = str(ProductPrice2)
  ProductPrice2 = ("£" + ProductPrice2)
  ProductPrice3 = str(ProductPrice3)
  ProductPrice3 = ("£" + ProductPrice3)
  ProductPrice4 = str(ProductPrice4)
  ProductPrice4 = ("£" + ProductPrice4)
  ProductPrice5 = str(ProductPrice5)
  ProductPrice5 = ("£" + ProductPrice5)
  ProductPrice6 = str(ProductPrice6) 
  ProductPrice6 = ("£" + ProductPrice6)

  # AFTER GETTING ALL OF THE DATA NECESSARY FOR THE HOME PAGE, WHICH IS THE PRODUCTS PRICE, COST OF SHIPPING AND THEIR NAME, WE'RE ABLE TO HTTP RESPOND BACK THE HOME PAGE TO THE FRONTEND FOR THE USER, USING HTML VARIABLES TO BE ABLE TO SHOW THE USER THE 3 KEY PIECES OF INFORMATION OF EACH PRODUCT TO THE FRONTEND

  return render_template("HomePage.html", ProductPrice1=ProductPrice1, ProductPrice2=ProductPrice2, ProductPrice3=ProductPrice3, ProductPrice4=ProductPrice4, ProductPrice5=ProductPrice5, ProductPrice6=ProductPrice6, ProductName1=ProductName1, ProductName2=ProductName2, ProductName3=ProductName3, ProductName4=ProductName4, ProductName5=ProductName5, ProductName6=ProductName6, ProductShipping1=ProductShipping1, ProductShipping2=ProductShipping2, ProductShipping3=ProductShipping3, ProductShipping4=ProductShipping4, ProductShipping5=ProductShipping5, ProductShipping6=ProductShipping6)           # BACKEND SENDS THE HOMEPAGE, WITH ALL THE NEEDED HTML VARIABLES
# [===] [===] #

# [===] ABOUT US PAGE [===] #
@app.route("/AboutUs", methods=["POST", "GET"])    # ENABLES POST AND GET REQUESTS
def AboutUs():                                     # SUBROUTINE FOR THE ABOUT US PAGE
  return render_template("AboutUs.html")           # BACKEND SENDS THE ABOUT US PAGE
# [===] [===] #

# [===] SIGN UP PAGE [===] #
@app.route("/Account", methods=["POST", "GET"])    # ENABLES POST AND GET REQUESTS
def Account():                                     # SUBROUTINE FOR THE ACCOUNT PAGE
  if "Username" in session and "Password" in session and "Email" in session: # IN CASE USER IS ALREADY LOGGED IN
    return redirect(url_for("LogOut"))                                       # GET SENT TO THE LOGOUT PAGE INSTEAD
    
  elif request.method == "POST":             # IF USER IS TRYING TO SEND DATA TO THE SERVER
    Username = request.form["USERNAME"]      # WE RECEIVE THE USERNAME, EMAIL AND PASSWORD FROM THE FRONTEND 
    Email = request.form["EMAIL"]
    Password = request.form["PASSWORD"]
    
    PasswordVerify = False                   # USED AS A LOCAL VARIABLE TO CHANGE WHEN VERIFYING THE USER'S PASSWORD
    
    try:                                     # TRY AND EXCEPT CLAUSE IN CASE THINGS DOESN'T WORK OUT
      for x in Username:                     # FOR LOOP THROUGHOUT THE USERNAME TO FIND SPACES OR EMPTINESS AND REMOVE IT
        if x == "" or x == " ":
          Username.remove(x)
    
    except:
      pass                                   # ELSE PASS
  
    UsernameCount = len(Username)            # KEEP A COUNT OF HOW LONG THE USERNAME IS WITHOUT SPACES

    pattern = '([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+'
    # PATTERN TO VERIFY THE USER'S EMAIL
    
    if (re.search(pattern, Email)):  # IF THEIR EMAIL IS CORRECT ACCORDING TO THE PATTERN, THEY CAN CONTINUE
      pass
    else: # ELSE THE ACCOUNT PAGE IS SENT FROM THE BACKEND WITH AN ERROR MESSAGE REGARDING THEIR EMAIL
      return render_template("Account.html", ErrorMessage="You need to input a legitimate email.")   
    
    try: # TRY AND EXCEPT CLAUSE IN CASE ANYTHING GOES WRONG
      for x in Password: # GOES THROUGH ALL OF THE CHARACTERS IN THE PASSWORD AND IF THERE'S ANY SPACES/NULL ELEMENTS, PASSWORD VERIFY IS TRUE
        if x == "" or x == " ":
          PasswordVerify = True
    
    except: # ELSE IT SHALL STAY AS FALSE
      PasswordVerify = False
    
    if UsernameCount < 8:      # AFTER REMOVING ANY POSSIBLE SPACES WITHIN THE USERNAME, THIS IS TO CHECK THAT THE USERNAME IS LESS THAN 8 CHARACTERS LONG OR NOT
      Needed = 8 - UsernameCount # CONSEQUENTLY, WE CAN FIND THEIR ACTUAL COUNT AND TAKE IT AWAY FROM 8
      Needed = str(Needed) # TO THEN MAKE THE CHARACTERS THEY ARE SHORT OF, INTO A STRING
      return render_template("Account.html", ErrorMessage="Your username is " + Needed + " characters short.")
      # TO BE ABLE TO RETURN THE HTML PAGE WITH THE ERROR MESSAGE, NOTIFYING THAT THE USER'S USERNAME IS X AMOUNT OF CHARACTERS SHORT
    
    elif PasswordVerify == True: # ELSE, IF THE USERNAME IS MORE THAN 8 CHARACTERS LONG
      return render_template("Account.html", ErrorMessage="Spaces aren't allowed within the password.")
      # IT'LL HTTP RESPOND BACK THE ACCOUNT HTML PAGE NOTIFYING THE USER THAT SPACES AREN'T ALLOWED WITHIN THE PASSWORD
    
    else:   # AFTER CHECKING IF THE PASSWORD AND USERNAME FITS THE REQUIREMENTS, THIS ALGORITHM IS THEN USED TO CHECK THEIR EMAIL
      EmailCount = 0 # AN COUNT OF HOW MANY TIMES THE EMAIL HAS BEEN USED FOR AN ACCOUNT IS A CONSTANT OF 0
    
      cursor.execute("SELECT Email FROM tblUsers WHERE Email = ?", (Email,))
      # IT GOES THROUGH THE USER TABLE TO SEE IF THE EMAIL HAS BEEN USED BEFORE OR NOT
      for x in cursor.fetchall():
        EmailCount += 1

        # IF IT HAS BEEN USED BEFORE, THAN WE KNOW THAT THE USER CANNOT MAKE/SIGN UP ANOTHER ACCOUNT AGAIN, AS THE EMAIL IS BEING USED
        # SO EMAIL COUNT IS INCREMENTED
    
      if EmailCount == 0: # IF THE EMAIL WASN'T USED, THAN EMAIL COUNT STAYS AS 0
        cursor.execute("INSERT INTO tblUsers (Username, Email, Password) VALUES (?, ?, ?)", (Username, Email, Password))
        # THIS ENSURES THAT THE EMAIL HASN'T BEEN USED BEFORE TO CREATE AN ACCOUNT, AND THUS, WILL UPDATE THE USER TABLE ABOUT THE NEW ACCOUNT CREATED
        db.commit()
        # WITH THE COMMIT COMMAND TO ENSURE TO SAVE THE UPDATE OF DATA INTO THE TABLE

        session.permanent = True
        session["Username"] = Username
        session["Email"] = Email
        session["Password"] = Password

        # AS THE USER HAS NOW SUCCESSFULLY SIGNED UP AND MADE AN ACCOUNT, ALL SESSION DATA IS NOW TURNED ON
        # THIS IS SO WHEN THEY NAVIGATE THROUGHOUT THE WEBSITE, THEY WON'T BE REQUIRED TO LOGIN INTO THEIR ACCOUNT, THAT THEY JUST MADE
        
        return redirect(url_for("HomePage"))
        # WITH IT SENDING THEM BACK TO THE HOME PAGE, AFTER THEY'VE FINISHED CREATING AN ACCOUNT
    
      elif EmailCount > 0:
        return render_template("Account.html", ErrorMessage="This email has already been used.")
        # ELSE IF THE EMAIL HAS BEEN USED BEFORE, THAN WE SEND BACK THE ACCOUNT HTML PAGE, NOTIFYING THEM THAT THE EMAIL HAS BEEN USED
        # AND THEIR SIGN UP PROCESS HAS FAILED

  else:
    return render_template("Account.html")
    # ELSE, IF NO DATA WAS SENT TO THE SERVER, THAN IT'LL JUST SEND THE ACCOUNT/SIGN UP PAGE, FOR THE USER TO UTILISE
# [===] [===] #
    

# [===] LOGIN PAGE [===] #
@app.route("/Login", methods=["POST", "GET"]) # THIS IS TO MAKE THE LOGIN PAGE TO BE ABLE TO ACCEPT BOTH POST AND GET REQUESTS
def Login():
  if "Username" in session and "Password" in session and "Email" in session: # INCASE THE USER IS ALREADY LOGGED IN USING SESSION DATA, 
    return redirect(url_for("LogOut")) # WE'LL JUST SEND THEM TO THE LOGOUT PAGE AS THEY'RE ALREADY LOGGED IN
    
  elif request.method == "POST": # ELSE, THAN WE'LL USE THE POST REQUEST METHOD TO TAKE IN THEIR LOGIN DETAILS
    Username = request.form["USERNAME"] # THESE LINES OF CODE WILL BE ABLE TO TAKE THE HTML VARIABLE INTO A PYTHON VARIABLE AND GO THROUGH A VERIFICATION PROCESS
    Email = request.form["EMAIL"]
    Password = request.form["PASSWORD"]

    if Username == "AdminRice" and Email == "Admin@RiceCooker.com" and Password == "AdminRice":
      return redirect(url_for("AdminAnalysis"))

    else:
      pass

    PasswordVerify = False # THIS IS A CONSTANT TO USE LATER ON WHEN CHECKING FOR THE AUTHENTICATION OF THE USER PASSWORD

    try: # TRY AND EXCEPT CLAUSE IN CASE ANYTHING DOESN'T WORK
      for x in Username: # WE'LL GO THROUGH THE USERNAME AND REMOVE ANY SPACES OR NULL ELEMENTS INSIDE OF IT
        if x == "" or x == " ": # UTILISING THE IF AND REMOVE STATEMENTS
          Username.remove(x)

    except: # IF THE USERNAME HAS NO SPACES OR NULL ELEMENT, THAN WE'LL PASS
      pass

    UsernameCount = len(Username) # WE THEN CHECK THE LENGTH OF THE USERNAME, JUST TO ENSURE THAT THE USER TYPED IN AN USERNAME

    pattern = '([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+' # FOR REGULAR EXPRESSIONS, THIS PATTERN IS USED TO ENSURE THE EMAIL ADDRESS IS LEGIT

    if (re.search(pattern, Email)): # WE'LL CHECK IF THE EMAIL ADDRESS IS LEGIT, IF IT IS, THAN PASS
      pass
    else: # ELSE, THAN HTTP RESPOND BACK THE LOGIN PAGE WITH THE ERROR MESSAGE THAT THEY NEED A LEGIT EMAIL
      return render_template("Login.html", ErrorMessage="You need to input a legitimate email.")   

    try: # TRY AND EXCEPT CLAUSE IN CASE ANYTHING BREAKS
      for x in Password: # GOING THROUGH THE PASSWORD AND FINDING FOR ANY SPACES/NULL ELEMENTS TO REMOVE, TO ENSURE THEY PUT IN A PASSWORD
        if x == "" or x == " ":
          PasswordVerify = True # IF THERE ARE NULL/SPACE ELEMENTS, WE CAN TELL THEY DIDN'T PUT A PROPER PASSWORD IN AS IT DOESN'T ALLOW SPACES/NULL ELEMENTS
            # CONSEQUENTLY THE CONSTANT IS SET TO TRUE, TO BE USED IN LATER USAGE
    except:
      PasswordVerify = False # ELSE, THE CONSTANT STAYS AS FALSE AND THE VERIFICATION PROCESS CONTINUES

    if UsernameCount < 8: # IF IT DOES TURNS OUT THAT THE USERNAME IS SHORTER THAN 8 CHARACTERS, WE FIND OUT THE NUMBER OF CHARACTERS THEY'RE SHORT OF
      Needed = 8 - UsernameCount
      Needed = str(Needed) # DATA CAST TYPE CONVERT IT INTO A STRING TO HTTP RESPOND BACK THE LOGIN PAGE, WITH ERROR MESSAGE SAYING THEY'RE X SHORT CHARACTERS
      return render_template("Login.html", ErrorMessage="Your username is " + Needed + " characters short.")

    elif PasswordVerify == True: # ELSE IF PASSWORD CONSTANT IS TRUE, THAN IT'LL HTTP RESPOND BACK THE LOGIN PAGE, STATING SPACES AREN'T ALLOWED IN THE PASSWORD
      # AS AN ERROR MESSAGE
      return render_template("Login.html", ErrorMessage="Spaces aren't allowed within the password.")

    else: # AS ALL OF THE DATA INPUTS ARE CORRECT, IT'S NOW CHECKING TO SEE IF THEIR DETAILS ARE CORRECT FOR THE USER ACCOUNT
      CorrectCount = 0 # THIS IS A CONSTANT TO SEE IF THERE'S AN ACCOUNT
      cursor.execute("SELECT * FROM tblUsers WHERE Email = ? AND Username = ? AND Password = ?", (Email, Username, Password,))
      for x in cursor.fetchall(): # SQL STATEMENT TO CHECK THE USER TABLE IF THE DETAILS MATCHES ANY ACCOUNTS
        CorrectCount += 1 # IF THE DETAILS DID MATCH, THAN CORRECT COUNT WOULD ONLY INCREMENT ONCE, ELSE SOMETHING IS WRONG

      if CorrectCount == 1: # IF CORRECT COUNT IS 1, THAN SESSION DATA IS TURNED ON WITH THE SPECIFIC AND RELEVANT LOGIN DETAILS

        session.permanent = True
        session["Username"] = Username
        session["Email"] = Email
        session["Password"] = Password
        
        return redirect(url_for("HomePage")) # USER IS NOW LOGGED IN, IN SESSION DATA AND IS HTTP RESPONDED BACK TO THE HOME PAGE

      else: # IF NOT, THAN THE USER HAS TYPED IN THE WRONG LOGIN DETAILS, AND WILL BE HTTP RESPONDED BACK THE LOGIN PAGE WITH ERROR MESSAGE ACCOUNT DETAILS ARE WRONG
        return render_template("Login.html", ErrorMessage="Account details are wrong.")
  
  else:
    return render_template("Login.html") # IF THE USER DOESN'T TRY TO LOG IN OR ISN'T IN SESSION DATA, THEY'LL JUST BE HTTP RESPONDED THE LOGIN PAGE
# [===] [===] #

# [===] LOGOUT PAGE [===] #
@app.route("/LogOut", methods=["POST", "GET"])  # THIS IS THE LOGOUT PAGE, WHICH ALLOWS BOTH POST AND GET REQUESTS FROM THE USER
def LogOut(): # THIS IS THE SUBROUTINE ESTABLISHING THE LOGOUT PAGE
  Username = session.get("Username") # IF THE USER IS IN SESSION DATA, THAN WE'LL GET THEIR USERNAME AND HTTP SEND BACK THE LOGOUT PAGE WITH THEIR NAME
  return render_template("LogOut.html", USERNAME=Username)
# [===] [===] #

# [===] LOGGING OUT [===] #  
@app.route("/ActuallyLoggedOut", methods=["POST", "GET"]) # THIS IS THE PROCESS OF THE USER LOGGING OUT THROUGH A GET REQUEST
def ActuallyLoggedOut(): # USING THIS SUBROUTINE TO BE ABLE TO FORWARD THE PROCESSES OF LOGGING OUT
  session.pop("Username", None) # THIS IS BY REMOVING ALL SESSION DATA SO THE USER IS FULLY LOGGED OUT
  session.pop("Email", None)
  session.pop("Password", None)

  return redirect(url_for("Account")) # THAN THEY'LL BE HTTP RESPONDED BACK THE SIGN UP PAGE
# [===] [===] #

# [===] INSIGHTS AND RECIPES [===] #
@app.route("/InsightsAndRecipes", methods=["POST", "GET"]) # THIS IS THE INSIGHTS AND RECIPES PAGE, WITH POST AND GET REQUESTS ENABLED
def InsightsAndRecipes():
  cursor.execute("SELECT PostID FROM tblInsightsAndRecipes") # FIRST, IT'LL GET THE POST ID, IT'LL GO THROUGH EVERYTHING SO THE FINAL POSTID IS THE RECENT POST
  for x in cursor.fetchall():
    PostNumber = x # WITH THE RECENT POST NUMBER BEING ASSIGNED TO THIS VARIABLE

  cursor.execute("SELECT Title FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # CONSEQUENTLY, WE CAN USE THIS POST ID TO FIND THE RECENT POST TITLE BY SQL SELECT STATEMENTS
    Title = x # ASSIGNING THE TITLE TO THIS VARIABLE TO USED ON LATER

  cursor.execute("SELECT Content FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # USING SQL SELECT STATEMENTS, WE CAN FIND THE RECENT POST CONTENT AS WELL
    Paragraph = x # ASSIGNING THE CONTENT TO THIS VARIABLE TO USED ON LATER

  # THE FOLLOWING CODE IS TO REMOVE THE BRACKETS, COMMAS AND QUOTATION MARKS THAT THE VARIABLES ARE IN DUE TO BEING IN A SQL TABLE
  TitleArray = [] # FIRST CREATING AN ARRAY TO STORE THE TITLE IN
  for i in Title: # WE GO THROUGH EVERYTHING IN THE TITLE TO REMOVE THE FOLLOWING ELEMENTS INSIDE OF IT
    if i == "(" or i == ")" or i == "," or i == "'":
      pass # BY SIMPLY PREVENTING IT BEING ADDED TO THE TITLE ARRAY

    else: # AND THE ACTUAL TITLE IS THEN PUT IN TITLE ARRAY, TO USE AS A TEMPORARY MEMORY LOCATION, THROUGH THE APPEND COMMAND
      TitleArray.append(i)
        
  Title = ("".join(TitleArray)) # AS A RESULT, EVERYTHING IN THE ARRAY IS JOINED TOGETHER, TO GET THE TITLE WHILST REMOVING THE SQL FORMAT IT WAS IN

  ParagraphArray = [] # A SIMILAR PROCESS FOR THE ACTUAL CONTENT, WHERE AN ARRAY IS SET UP AS A TEMPORARY MEMORY LOCATION
  for i in Paragraph: # GOING THROUGH EVERYTHING IN THE CONTENT TO AVOID APPENDING THESE ELEMENTS INTO THE ARRAY, TO REMOVE THE SQL FORMAT
    if i == "(" or i == ")" or i == "," or i == "'":
      pass

    else: # WITH THE ACTUAL CONTENT BEING APPENDED TO THIS TEMPORARY MEMORY LOCATION
      ParagraphArray.append(i)

  Paragraph = ("".join(ParagraphArray)) # THAN JOINING ALL OF THE ELEMENTS TOGETHER TO BRING BACK THE CONTENT IN IT'S ORIGINAL STATE WITHOUT THE SQL FORMAT

  PostNumber = str(PostNumber) # THIS IS DATA TYPE CONVERTING THE POST NUMBER TO A STRING TO SHOW IT ON THE FRONTEND, AND TO REMOVE IT'S SQL FORMAT
  
  PostNumberArray = [] # AN ARRAY IS ESTABLISHED AS A TEMPORARY MEMORY LOCATION
  for i in PostNumber: # ANYTHING IN THE POST ID THAT IS PART OF THE SQL FORMAT IS PREVENTED TO BE ADDED IN TO THE ARRAY
    if i == "(" or i == ")" or i == "," or i == "'":
      pass

    else: # THE ACTUAL POST ID CONTENT IS APPENDED TO THE ARRAY
      PostNumberArray.append(i)

  PostNumber = ("".join(PostNumberArray)) # CONTENT OF THE ARRAY IS JOINED TOGETHER TO CONVEY THE ACTUAL POSTID
  global CurrentPostCount # GLOBALISING THIS VARIABLE SINCE WE'RE CHANGING IT
  CurrentPostCount = int(PostNumber) # CURRENT POST IS THE POST NUMBER, SO WHEN MOVING TO OLDER/RECENT POSTS, WE KNOW THIS IS WHERE WE ARE IN THE ORDER
  global MaxPosts # THIS IS ALSO TO GLOBALISE THE VARIABLE OF HOW MANY POSTS THERE ARE, SO THE WEBSITE CAN'T GET ANYTHING OLDER THAN X POST
  MaxPosts = int(PostNumber) # ENSURING THAT IT'S AN INTEGER

  return render_template("InsightsAndRecipes.html", TITLE=Title, PARAGRAPH=Paragraph, POSTNUMBER=PostNumber)
  # AFTER THAT IS DONE, IT HTTP RESPONDS BACK THE INSIGHTS AND RECIPES PAGE WITH THE TITLE, PARAGRAPH AND POSTNUMBER OF THE CURRENT LATEST POST
# [===] [===] #

# [===] INSIGHTS AND RECIPES OLD [===] #
@app.route("/InsightsAndRecipesOld", methods=["POST", "GET"]) # THIS IS WHERE THE USER IS SENT WHEN THEY TRY TO GET TO AN OLDER POST
def InsightsAndRecipesOld(): # WITH THE SUBROUTINE BEING THE CODE TO MOVE TO THE OLDEST POST (DECREMENTING)
  global CurrentPostCount # FIRST GLOBALISING THE CURRENT POST COUNT AS WE'RE NOW ON A NEW POST

  if CurrentPostCount == 1: # IF CURRENT POST COUNT IS 1, MEANS THAT WE'RE ALREADY ON THE OLDEST POST AND DON'T NEED TO MOVE
    pass # SO JUST PAST

  else: # IF WE'RE NOT ALREADY ON THE OLDEST POST, THAN WE JUST DECREMENT IT TO GET TO THE NEXT OLDEST POST
    CurrentPostCount -= 1
  
  CurrentPostCount = str(CurrentPostCount) # AS SUCH THE NEW CURRENT POST NUMBER IS A STRING FOR LATER USE
  PostNumber = CurrentPostCount # THE POST NUMBER IS THE CURRENT POST COUNT, AKA THE NEXT OLD POST WE'RE ON
  CurrentPostCount = int(CurrentPostCount) # WHICH IS THEN BACK TO AN INTEGER FOR LATER USE

  cursor.execute("SELECT Title FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # AS A RESULT, WE USE THE POST NUMBER TO FIND THE TITLE OF THE OLDER POST, THROUGH SQL SELECT STATEMENT
    Title = x # THIS IS THE OLDER POST TITLE

  cursor.execute("SELECT Content FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # USING THE POST NUMBER TO FIND THE CONTENT OF THE OLDER POST, THROUGH SQL SELECT STATEMENT
    Paragraph = x # WITH THE OLDER POST CONTENT BEING STORED TO THIS VARIABLE

  TitleArray = [] # THIS IS A TEMPORARY MEMORY LOCATION TO STORE THE TITLE IN WHEN TRYING TO REMOVE IT FROM IT'S SQL FORMAT
  for i in Title: # GOING THROUGH ALL OF THE ELEMENTS IN THE TITLE TO PREVENT THE SQL FORMAT BEING ADDED INTO THE TEMPORARY MEMORY LOCATION
    if i == "(" or i == ")" or i == "," or i == "'":
      pass # ACCOMPLISHING IT WITH A PASS

    else: # HOWEVER, IF IT IS PART OF THE TITLE, IT'S APPENDED TO THE TEMPORAY MEMORY LOCATION
      TitleArray.append(i)
        
  Title = ("".join(TitleArray)) # WITH ALL OF THE ARRAY'S ELEMENTS BEING JOINED TOGETHER TO FORM AS THE TITLE

  ParagraphArray = [] # TEMPORARY MEMORY LOCATION TO STORE THE PARAGRAPH IN WHEN TRYING TO REMOVE IT FROM IT'S SQL FORMAT
  for i in Paragraph: # GOING THROUGH ALL OF THE ELEMENTS IN THE PARAGRAPH TO PREVENT THE SQL FORMAT BEING PART OF THE TEMPORARY MEMORY LOCATION
    if i == "(" or i == ")" or i == "," or i == "'":
      pass # DONE WITH A PASS AND AN IF STATEMENT

    else: # ELSE, ALL OF THE PARAGRAPH CONTENT IS APPENDED TO THIS MEMORY LOCATION TO BE USED LATER ON
      ParagraphArray.append(i)

  Paragraph = ("".join(ParagraphArray)) # USING THE JOIN COMMAND SO THE PARAGRAPH IS TAKEN FROM THE ARRAY INTO AN ACTUAL PARAGRAPH

  return render_template("InsightsAndRecipes.html", TITLE=Title, PARAGRAPH=Paragraph, POSTNUMBER=PostNumber)
  # THIS THEN HTTP RESPONDS BACK THE POST HTML PAGE, WITH THE TITLE, PARAGRAPH AND THE OLDER POST NUMBER
  
# [===] [===] #

# [===] INSIGHTS AND RECIPES RECENT [===] #
@app.route("/InsightsAndRecipesRecent") # IN CASE THE USER WANTS A MORE RECENT POST, THAN WE USE THIS BLOCK OF CODE
def InsightsAndRecipesRecent(): # SUBROUTINE ESTABLISHING THE CODE FOR THE RECEPT POST OF THE INSIGHTS AND RECIPES PAGE
  global CurrentPostCount # GLOBALISING THESE VARIABLES TO SEE WHAT'S THE CURRENT POST WE'RE ON, AND WHAT'S THE MAX NUMBER OF POSTS AVAILABLE
  global MaxPosts

  if CurrentPostCount == MaxPosts: # IF THE CURRENT POST WE'RE ON IS THE MAX, THAN WE PASS AS WE CANNOT GO ANY MORE RECENT THAN THIS
    pass

  else: # ELSE WE INCREMENT TO THE CURRENT POST COUNT, TO BE ABLE TO GO TO THE NEXT AVAILABLE RECENT POST
    CurrentPostCount += 1

  CurrentPostCount = str(CurrentPostCount) # AS SUCH THE CURRENT POST COUNT IS TEMPORARILY CONVERTED TO A STRING
  PostNumber = CurrentPostCount # SO WE CAN GET THE POST NUMBER TO USE FOR SQL SELECTING STATEMENTS
  CurrentPostCount = int(CurrentPostCount) # AND TURNING BACK THE CURRENT POST COUNT TO AN INTEGER

  cursor.execute("SELECT Title FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # THIS IS USED TO FIND THE TITLE OF THE NEXT RECENT POST THROUGH A SQL SELECT STATEMENT
    Title = x # THAN STORING THE TITLE OF THE NEXT RECENT POST TO THIS VARIABLE

  cursor.execute("SELECT Content FROM tblInsightsAndRecipes WHERE PostID=?", (PostNumber))
  for x in cursor.fetchall(): # THIS IS USED TO FIND THE PARAGRAPH OF THE NEXT RECENT POST THROUGH A SQL STATEMENT
    Paragraph = x # THAN STORING THE PARAGRAPH OF THE NEXT RECENT POST TO THIS VARIABLE

  TitleArray = [] # THIS IS A TEMPORARY ARRAY TO STORE THE NEXT RECENT POST TITLE IN, TO REMOVE IT'S SQL FORMAT
  for i in Title: # GOING THROUGH THE TITLE TO REMOVE ANY PRESENCE OF THE SQL FORMAT
    if i == "(" or i == ")" or i == "," or i == "'":
      pass # THIS IS DONE THROUGH PASS AND PREVENTING IT TO BE PART OF THE TITLE ARRAY MEMORY LOCATION

    else: # ELSE, THE ACTUAL CONTENT OF THE NEXT RECENT POST TITLE, IS APPENDED TO THIS ARRAY
      TitleArray.append(i)
        
  Title = ("".join(TitleArray)) # WITH ALL OF THE ELEMENTS BEING JOINED TOGETHER TO FORM THE NEXT RECENT POST TITLE WITHOUT THE SQL FORMAT

  ParagraphArray = [] # THIS IS AN ARRAY TO TEMPORARILY STORE THE NEXT RECENT POST PARAGRAPH CONTENT
  for i in Paragraph: # THIS IS BY GOING THROUGH THE PARAGRAPH AND PREVENTING TO APPEND ANY OF THE SQL FORMAT INTO THE PARAGRAPH
    if i == "(" or i == ")" or i == "," or i == "'":
      pass # ACCOMPLISHED BY AN IF STATEMENT AND THROUGH PASS

    else: # ELSE, ALL OF THE CONTENT OF THE PARAGRAPH ARRAY IS APPENDED TO THIS ARRAY TEMPORARILY WHILST THIS PROCESS IS BEING FINISHED
      ParagraphArray.append(i)

  Paragraph = ("".join(ParagraphArray)) # AFTER GETTING ALL OF THE CONTENT OF THE PARAGRAPH, IT'S JOINED TOGETHER TO TAKE IT OUT OF THE ARRAY

  return render_template("InsightsAndRecipes.html", TITLE=Title, PARAGRAPH=Paragraph, POSTNUMBER=PostNumber)
  # TO CONCLUDE, THE INSIGHTS AND RECIPES PAGE IS HTTP RESPONDED BACK, WITH THE NEXT RECENT POST TITLE, PARAGRAPH AND POST NUMBER OF THIS POST
# [===] [===] #

# [===] CONTACT US PAGE [===] #
@app.route("/ContactUs", methods=["POST", "GET"]) # THIS IS THE HTML PAGE FOR THE CONTACT US, ACCEPTING BOTH POST AND GET REQUESTS
def ContactUs(): # THIS IS THE SUBROUTINE THAT SHALL HOLD THE CODE FOR THE PROCESSING OF THE CONTACT US PAGE 
  if request.method == "POST": # THIS IS CHECKING IF THE USER IS SENDING A POST REQUEST OR NOT FIRST
    FirstName = request.form["FIRSTNAME"] # AS IT IS, IT'S RECEIVING ALL OF THE INPUTS THE USER TYPED IN, INTO THESE VARIABLES
    LastName = request.form["LASTNAME"]
    EnquiryEmail = request.form["EMAIL"]
    Country = request.form["COUNTRY"]
    Enquiry = request.form["ENQUIRY"]
    EmailMessage  = request.form["EMAILMESSAGE"]

    # THE FOLLOWING CODE ENSURES THAT THE DATA THEY PUT IN, EXISTS OR NOT
    try: # TRY AND EXCEPT CLAUSE TO ENSURE THAT THE FIRST NAME EXISTS
      for x in FirstName: # GOING THROUGH EVERYTHING OF THE FIRST NAME, IF IT FINDS ANY NULL/SPACE ELEMENTS, IT'S REMOVED
        if x == " " or x == "":
          FirstName.remove(x) # ACHIEVED BY AN IF STATEMENT AND REMOVE COMMAND

    except: # ELSE IF THE FIRSTNAME THAT THE USER TYPED IN DOES EXIST, THAN WE CAN JUST PASS THROUGH THIS PROCESS
      pass

    if len(FirstName) == 0: # THIS IS THEN CHECKING HOW LONG THE FIRST NAME IS
      return render_template("ContactUs.html", ERRORMESSAGE="Please enter something for the first name slot.")
      # IF IT'S 0, WE CAN ASSUME THAT THE USER TYPED IN NOTHING OR JUST SPACES, SO WE SEND BACK THE CONTACT US PAGE WITH THE ERROR MESSAGE TO TYPE A FIRSTNAME

    try: # ELSE IT PROCEEDS TO CHECK IF THE LAST NAME HAS BEEN ENTERED IN OR NOT
      for x in LastName: # THIS GOES THROUGH THE ENTIRETY OF THE LASTNAME
        if x == " " or x == "": # IF THERE'S ANY SPACE OR NULL ELEMENTS, IT SHALL BE REMOVED 
          LastName.remove(x)

    except: # IF THE USER DID PUT IN SOMETHING, THAN PASS
      pass

    if len(LastName) == 0: # THIS IS CHECKING IF THE LAST NAME DOESN'T EXIST OR NOT
      return render_template("ContactUs.html", ERRORMESSAGE="Please enter something for the last name slot.")
      # IF THE LAST NAME LENGTH IS EQUAL TO 0, IT'S ASSUMED THAT THEY DIDN'T TYPED IN ANYTHING, SO IT HTTP RESPOND BACK THE CONTACT US PAGE, WITH ERROR MESSAGE TO TYPE SOMETHING IN FOR THE LAST NAME INPUT BOX

    pattern = '([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+' # THIS IS THE REGULAR EXPRESSIONS PATTERN TO VERIFY THE EMAIL

    if (re.search(pattern, EnquiryEmail)):
      pass # IF THE EMAIL TYPED FOLLOWS THE PATTERN, THAN IT'LL PASS AND CONTINUE WITH THE PROCESS

    else: # ELSE, IT'LL HTTP RESPOND BACK THE CONTACT US PAGE, WITH THE ERROR MESSAGE THAT THE EMAIL IS WRONG
      return render_template("ContactUs.html", ERRORMESSAGE="You need to input a legitimate email.")

    try: # TRY AND EXCEPT CLAUSE IN CASE ANYTHING FAILS, THIS IS CHECKING IF THE USER PROVIDED THEIR COUNTRY
      for x in Country: # GOING THROUGH EACH CHARACTERS OF THE COUNTRY THEY INPUT, CHECKING FOR ANY NULL OR SPACE ELEMENTS
        if x == " " or x == "":
          Country.remove(x) # ANY OF THOSE ELEMENTS ARE REMOVED FROM THE COUNTRY THEY PROVIDED

    except: # OTHERWISE, IF THE COUNTRY THEY PROVIDED IS JUST CHRACTERS, THAN IT'LL PASS
      pass

    if len(Country) == 0: # CHECKING THE LENGTH OF THE COUNTRY AFTER REMOVING ANY UNWANTED CHARACTERS TO SUGGEST THERE'S NO INPUT
      return render_template("ContactUs.html", ERRORMESSAGE="Please put down the country you're from.")
      # IF IT IS 0, THAN THEY DIDN'T PUT IN A COUNTRY, HTTP RESPOND BACK THE CONTACT US PAGE WITH AN ERROR MESSAGE

    try: # TRY AND EXCEPT CLAUSE IN CASE ANYTHING GOES WRONG, THIS IS VERIFYING THAT THEY TYPED IN THEIR ENQUIRY
      for x in Enquiry: # GOING THROUGH ALL OF THE CHARACTERS IN THE ENQUIRY TO REMOVE ANY NULL OR SPACE ELEMENTS
        if x == " " or x == "":
          Enquiry.remove(x) # WHICH IS ACHIEVED BY AN IF STAEMENT AND REMOVE 

    except: # IF THE ENQUIRY IS JUST CHARACTERS, IT PASSES AND CONTINUES TO PROCEEDS ON
      pass

    if len(Enquiry) == 0: # THIS IS THEN CHECKING THE LENGTH OF THE ENQUIRY, IF THERE ARE NO CHARACTERS WE CAN ASSUME THAT THEY DIDN'T TYPED IN ANYTHING, AS SUCH, THE CONTACT US PAGE IS HTTP RESPONDED BACK TO THE USER WITH AN ERROR MESSAGE
      return render_template("ContactUs.html", ERRORMESSAGE="Please enter something for the enquiry slot.")

    try: # THIS IS AN TRY AND EXCEPT CLAUSE TO ENSURE THAT THEY TYPE IN AN MESSAGE FOR THEIR EMAIL
      for x in EmailMessage: # THIS IS BY GOING THROUGH THE CONTENTS OF THE EMAIL MESSAGE, REMOVING ANY SPACE OR NULL CHARACTERS, SO WHAT'S LEFT IS SUPPOSEDLY THE EMAIL MESSAGE, IF IT'S JUST ALL CHARACTERS, THAN IT PASSES
        if x == " " or x == "":
          EmailMessage.remove(x) # REMOVING ANY NULL ELEMENTS

    except:
      pass

    if len(EmailMessage) == 0: # AS SUCH, IT LENS THE EMAIL MESSAGE, IF IT IS 0, WE CAN ASSUME ALL THEY TYPED IN WAS NULL OR SPACE ELEMENTS, AS SUCH NOTHING, THEN PROCEEDING TO HTTP RESPOND BACK THE CONTACT US PAGE WITH AN ERROR MESSAGE, UNLESS THEY DID PUT IN AN INPUT FOR THE EMAIL MESSAGE
      return render_template("ContactUs.html", ERRORMESSAGE="Please write an email message.")


    # THIS ENTIRE PIECE OF CODE IS TO FORMAT ALL OF THE INFORMATION THAT THE USER PROVIDED TO USE INTO A VARIABLE, AS A FORMAT, SO WHEN SENDING IT TO THE BUSINESS EMAIL, IT WON'T BE MULTIPLE EMAILS, BUT INSTEAD, 1 EMAIL WITH ALL OF THE CONTENT USING CONCATENATION
    Message = ("""
    Consumer First Name = """ + FirstName + """
    Consumer Last Name = """ + LastName + """
    Consumer's Country = """ + Country + """
    Consumer's Email = """ + EnquiryEmail + """

    Email's Enquiry:
    """ + Enquiry + """

    Email's Content:
    """ + EmailMessage + """
               """)
    # THIS IS ACHIEVED THROUGH CONCATENACTION ALL OF THE INFORMATION AS VARIABLES IN THIS FORMAT TO BE USED LATER ON

    gmail_user = 'REDACTED'
    gmail_password = 'REDACTED'
    # THIS IS ESTABLISHING THE USERNAME AND PASSWORD OF THE GMAIL ACCOUNT THAT THE BUSINESS USE, FOLLOWING THE SMTP SERVER BUILTIN FUNCTION

    FROM = EnquiryEmail
    TO = gmail_user
    SUBJECT = Enquiry
    TEXT = Message
    # THIS IS ACCORDANCE TO THE SMTP SERVER BUILTIN FUNCTION SYNTAX, WHERE IT MUST STATES WHERE THE EMAIL IS FROM (WHATEVER THE CONSUMER TYPED IN), WHO IT'S FOR (THE BUSINESS GMAIL USER ACCOUNT), ALONGSIDE THE SUBJECT WHICH IS THE ENQUIRY THAT THE CONSUMER INPUTTED AND THE ACTUAL TEXT WHICH IS THE MESSAGE FORMATTED ABOVE

    emailmessage = """From: %s\nTo: %s\nSubject: %s\n\n%s
    """ % (FROM, ", ".join(TO), SUBJECT, TEXT)
    # CONSEQUENTLY, ONCE AGAIN, FOLLOWING THE SMTP SERVER BUILTIN FEATURE, WE CONCATENACT EVERYTHING INTO THIS EMAIL MESSAGE VARIABLE

    
    server = smtplib.SMTP("smtp.gmail.com", 587)
    server.ehlo()
    server.starttls()
    server.login("ricecooker1111111111@gmail.com", "ricecooker!!!!")
    server.sendmail(FROM, TO, emailmessage)
    server.close
    # FOLLOWING THE SMTP SERVER SYNTAX, THE SERVER IS ESTABLISHED AS A GMAIL SERVER, USING PORT 587. WITH THE FOLLOWING CODE EHLO TO ESTABLISH THE SERVER AND STARTTLS TO MAKE IT MORE SECURE, USING LOGIN TO AUTHENTICATE THE BUSINESS EMAIL AND BE ABLE TO RECEIVE AN EMAIL, WITH THE SEND MAIL AS THE FINAL PIECE OF THE SYNTAX CODE OF THE SMTP SERVER, TO BE ABLE TO SEND THIS ENQUIRY TOWARDS THE BUSINESS EMAIL, AND THEN CLOSING THE SMTP SERVER

    return render_template("ContactUs.html", ERRORMESSAGE="Email sent successfully.")
      # CONSEQUENTLY, AFTER ALL OF THAT, THE USER IS HTTP RESPONDED BACK THE CONTACT US PAGE, STATING THAT THE EMAIL HAS BEEN SENT SUCCESSFULLY, THROUGH THE HTML VARIABLE ERRORMESSAGE

  else:
    return render_template("ContactUs.html")
    # ELSE IF THE USER DIDN'T SENT IN A POST REQUEST, BUT THIS IS A GET REQUEST, WE JUST HTTP RESPOND BACK THE USER WITH THE CONTACT US HTML PAGE
# [===] [===] #

# [===] WEB PAGES FOR EACH PRODUCT FROM THE PRODUCT PORTFOLIO [===] #
# [===] THE RICE MACHINE [===] #
@app.route("/TheRiceMachine", methods=["POST", "GET"]) # MAKES IT SO THIS HTML PAGE WILL ACCEPT BOTH POST AND GET REQUESTS FROM THE USER
def TheRiceMachine(): # THIS IS THE SUBROUTINE FOR THE RICE MACHINE, MEANING IF THE USER DOES GO ON THIS HTML PAGE, IT'LL DIRECT THEM TO HERE
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=1") # SQL SELECT STATEMENT TO RECEIVE THE PRODUCT'S PRICE, STOCK, SHIPPING, CAPACITY, COLOUR, VERSION AND DESCRIPTION FOR THE RICE MACHINE, USING A WHERE CLAUSE FOR WHEN PRODUCT ID IS 1
  for x in cursor.fetchall(): # FOR LOOPING THROUGH ALL OF THE INFORMATION ATTAINED AND ASSIGNING IT INTO THIS VARIABLE AS AN ARRAY
    Product1Information = x

  global ProductPrice # GLOBALISING ALL OF THESE VARIABLES, AS THEY'LL BE ASSIGNED TO THEIR RESPECTIVE DATA, TO BE USED LATER ON WHEN RETURNING THE RICE MACHINE HTML PAGE
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription
  
  ProductPrice = Product1Information[0] # RECEIVE THE PRODUCT PRICE BY INDEXING THE PRODUCT INFORMATION ARRAY BY 0 
  ProductStock = Product1Information[1] # RECEIVE THE PRODUCT STOCK BY INDEXING THE PRODUCT INFORMATION ARRAY BY 1
  if Product1Information[2] == 0: # RECEIVING THE PRODUCT'S SHIPPING PRICE BY INDEXING THE PRODUCT INFORMATION ARRAY BY 2
    ProductShipping = "Free" # IF IT'S EQUAL TO 0, THAN PRODUCT SHIPPING IS NOW LABELLED AS FREE
  else: # ELSE PRODUCT SHIPPING WILL BECOME THE INTEGER THAT IS INSIDE OF PRODUCT INFORMATION ARRAY
    ProductShipping = Product1Information[2]
    ProductShipping = str(ProductShipping) # WHICH IS THEN DATA CONVERTED TO A STRING AND BEEN CONCATENATED A POUND SYMBOL UP FRONT
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product1Information[3] # RECEIVE THE PRODUCT CAPACITY BY INDEXING PRODUCT INFORMATION ARRAY BY 3
  ProductColour = Product1Information[4] # RECEIVE THE PRODUCT COLOUR BY INDEXING PRODUCT INFORMATION ARRAY BY 4
  ProductVersion = Product1Information[5] # RECEIVE THE PRODUCT VERSION BY INDEXING THE PRODUCT INFORMATION ARRAY BY 5
  ProductDescription = Product1Information[6] # RECEIVE THE PRODUCT DESCRIPTION BY INDEXING THE PRODUCT INFORMATION ARRAY BY 6
  
  ProductPrice = str(ProductPrice) # DATA CONVERT TYPE PRODUCT PRICE INTO A STRING, TO THEN BE ABLE TO CONCATENATE A POUND SYMBOL IN FRONT
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity) # DATA CONVERT TYPE PRODUCT CAPACITY INTO A STRING TO BE USED LATER ON

  ReviewsArray = [] # AN ARRAY FOR ANY CURRENT REVIEWS OF THE PRODUCT TO BE APPENDED IN

  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 1 AND tblReviews.ProductID = 1") # USING SQL SELECT, WE RECEIVE REVIEWS FROM THE TBL REVIEWS WHERE THE TBL PRODUCT ID IS THE SAME AS THE RICE MACHINE, TO ENSURE WE GET THE RIGHT REVIEWS FOR THE RIGHT PRODUCT
  for x in cursor.fetchall(): # FOR LOOPING THROUGH ALL OF THE REVIEWS SELECTED, IT IS NOW APPENDED INTO THE ARRAY TO STORE REVIEWS
    ReviewsArray.append(x[0]) # USING INDEX 0 TO ENSURE THEY'RE NOT IN THE ('  '), FORMAT THEY'RE USUALLY IN

  for x in ReviewsArray: # FOR LOOPING THROUGHOUT THE REVIEWS ARRAY, TO REMOVE ANY ELEMENTS WHICH ARE JUST NULL ELEMENTS OR JUST BLANK SPACE
    if x.isspace():
      ReviewsArray.remove(x) # WHICH IS DONE BY REMOVE X

    else: # ELSE ANY REVIEWS IN THE ARRAY WHICH ARE PROPER STRINGS, WILL JUST BE PASSED
      pass

  if request.method == "POST" and "NewReview" in request.form: # IF THE REQUEST SENT FROM THE FRONTEND IS POST AND IT'S TO WRITE UP A NEW REVIEW
    if "Username" in session and "Password" in session and "Email" in session: # AND IF THE USER IS LOGGED IN, BY CHECKING THAT THEIR USERNAME, PASSWORD AND EMAIL ARE IN DATA SESSION
      NewReview = request.form["NewReview"] # RECEIVE THE NEW REVIEW SENT FROM THE USER BY REQUEST FORM AND ASSIGNING IT TO THIS VARIABLE

      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.": # IF THE REVIEW SENT BY THE USER IS JUST WHITE SPACE, OR THEY JUST SENT THE DEFAULT MESSAGE AS A REVIEW TO THE SERVER
        ErrorMessage = ("Reviews can't just be white space.") # AN ERROR MESSAGE WILL BE THAT THE USER CAN'T SEND REVIEWS THAT ARE WHITE SPACE
        return render_template("TheRiceMachine.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray) # SENDING THE PRODUCT RICE MACHINE HTML PAGE TO THE FRONTEND, WITH SAID ERROR MESSAGE, TO ALERT THE USER THAT THEIR REVIEW WON'T BE ACCEPTED

      else: # IF THE REVIEW ISN'T WHITE SPACE AND IS A PROPER STRING, THAN THE REVIEW PROCESS IS CONTINUED
        pass

      Username = session["Username"] # WE RECEIVE THE CURRENT USER'S USERNAME THROUGH DATA SESSION AS THIS VARIABLE

      NewReview = (NewReview + " - " + Username) # WITH THEN CONCATENATING THE REVIEW SENT BY THE USER, TO INCLUDE THE USER'S USERNAME WITH THE REVIEW
    
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 1)", [NewReview]) # CONSEQUENTLY, THIS REVIEW IS NOW INSERTED INTO THE DBMS, WITH PRODUCT ID 1 TO ENSURE THAT THE REVIEW IS MEANT TO BE FOR THE RICE MACHINE
      db.commit() # COMMITTING IT TO THE DBMS SO IT IS SAVED AND WILL BE SEEN IN FUTURE USE

    else: # ELSE IF THE USER TRIED TO SEND IN A REVIEW BUT THEY'RE NOT LOGGED INTO THEIR ACCOUNT CURRENTLY, THAN THE ERROR MESSAGE SHALL BE CREATED THAT THE USER NEED TO LOG IN TO BE ABLE TO TYPE UP AND SEND A REVIEW
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("TheRiceMachine.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray) # CONSEQUENTLY, THE RICE MACHINE HTML PAGE IS SENT TO THE FRONTEND WITH THE ERROR MESSAGE THAT THE USER NEEDS TO LOG IN TO BE ABLE TO WRITE AND SEND A REVIEW
    
  elif request.method == "POST": # ELSE, IF THE REQUEST METHOD IS POST, WE CAN ASSUME THIS IS THE USER TRYING TO ADD THE PRODUCT TO THEIR SHOPPING CART, AS THERE'S ONLY 2 POST REQUESTS OPEN (ONE TO SEND IN A REVIEW AND ANOTHER TO BE ABLE TO ADD THE PRODUCT TO THEIR SHOPPING CART)
    if "Username" in session and "Password" in session and "Email" in session: # THIS IS THEN ENSURING THAT THE USER IS LOGGED IN TO BE ABLE TO ADD A PRODUCT TO THEIR CART, BY CHECKING IF THEIR USERNAME, PASSWORD AND EMAIL IS IN SESSION DATA OR NOT
      UserEmail = session["Email"] # WE RECEIVE THE USER EMAIL THROUGH SESSION DATA, AND ASSIGN IT TO THIS VARIABLE

      CartEmails = [] # THIS IS AN ARRAY TO STORE ALL THE EMAILS WHICH HAS CURRENTLY HAVE A SHOPPING CART, JUST TO SEE IF WE NEED TO MAKE THIS USER A NEW SHOPPING CART OR CONTINUE WITH THEIR CURRENT CART

      cursor.execute("SELECT Email FROM tblAddToCart") # THIS IS DONE BY SELECTING ALL OF THE EMAILS FROM THE TBL ADD TO CART
      for x in cursor.fetchall(): # USING A FOR LOOP TO APPEND ALL OF THE EMAILS RECEIVED FROM THE TBL, TO THE ARRAY
        CartEmails.append(x[0]) # ENSURING TO USE INDEX 0, TO AVOID THE EMAIL BEING IN THE ('  '), FORMAT IT WOULD USUALLY BE IN

      if UserEmail in CartEmails: # IF THE USER'S EMAIL IS ALREADY IN THE ADD TO CART TABLE
        EmailInCart = True # THAN WE SET THIS VARIABLE TO TRUE FOR LATER PURPOSE

      else: # ELSE, WE CAN ASSUME THAT THE USER DOESN'T ALREADY HAVE A SHOPPING CART AND WE WILL SET THE VARIABLE TO FALSE, FOR LATER PURPOSE
        EmailInCart = False

      if EmailInCart == True: # IF THE EMAIL IN CART VARIABLE IS SET TO TRUE, WHERE WE CAN ASSUME THAT THE USER ALREADY HAVE A SHOPPING CART
        cursor.execute("Select TheRiceMachine FROM tblAddToCart WHERE Email=?", (UserEmail,)) # THAN WE RECEIVE HOW MANY CURRENT RICE MACHINES THEY ORDER, THROUGH THIS SQL SELECT STATEMENT, USING EMAIL AS THE PRIMARY KEY TO FIND THE RIGHT SHOPPING CART

        for x in cursor.fetchall(): # CONSEQUENTLY, WE FOR LOOP THROUGH THE DATA TO RECEIVE THE NUMBER OF RICE MACHINE RICE COOKERS THEY ORDERED
          RiceMachineOrders = x # ASSIGNING IT TO THIS VARIABLE

        RiceMachineOrdersNumber = RiceMachineOrders[0] # WHICH IS THEN ASSIGNED TO THIS VARIABLE, USING INDEX 0 TO AVOID THE RICE MACHINE ORDER NUMBER TO BE IN THE FORMAT OF ('  '),

        try: # DATA CONVERT TYPE THE NUMBER OF RICE MACHINE ORDERS TO AN INTEGER FOR LATER USAGE
          RiceMachineOrdersNumber = int(RiceMachineOrdersNumber)
        except: # IF IT TURNS OUT THAT THE USER DO HAVE A SHOPPING CART, BUT THEY DON'T HAVE ANY RICE MACHINE RICE COOKERS, THAN WE JUST SET THE RICE MACHINE ORDERS THEY HAVE TO 0 INSTEAD, AND THEN DATA CONVERT IT INTO A INTEGER
          RiceMachineOrdersNumber = 0
          RiceMachineOrdersNumber = int(RiceMachineOrdersNumber)
          
        RiceMachineOrdersNumber += 1 # THE RICE MACHINE ORDER NUMBER GETS INCREMENTED AS THIS IS INDICATING HOW THE PRODUCT IS ADDED TO THEIR SHOPPING CART
        RiceMachineOrdersNumber = str(RiceMachineOrdersNumber) # CONSEQUENTLY, IT IS DATA CONVERTED TYPE INTO A STRING FOR LATER PURPOSE

        cursor.execute("UPDATE tblAddToCart SET TheRiceMachine = ? WHERE Email=?", (RiceMachineOrdersNumber, UserEmail))
        db.commit() # UPDATING THE TBL ADD TO CART FOR THE USER, CHANGING THEIR CURRENT RICE MACHINE ORDER NUMBER TO THE NEWEST ONE, USING THE USER'S EMAIL AS A PRIMARY KEY

      elif EmailInCart == False: # HOWEVER, IF IT TURNS OUT THAT THE USER DOESN'T ALREADY HAVE A SHOPPING CART
          cursor.execute("INSERT INTO tblAddToCart (Email, TheRiceMachine) VALUES (?, ?)", (UserEmail, 1))
          db.commit() # THIS CREATES A SHOPPING CART FOR THE USER, SETTING THE RICE MACHINE PRODUCT ORDER NUMBER AS 1

    else: # IF THE USER ISN'T LOGGED IN BY CHECKING WITH SESSION DATA, THE ERROR MESSAGE IS SET TO THIS
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("TheRiceMachine.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray) # WHICH THEN THE RICE MACHINE HTML PAGE IS SENT TO THE FRONTEND WITH THIS VARIABLE ERROR MESSAGE TO ALERT THE USER THAT THEY NEED TO LOG IN TO BE ABLE TO ADD A PRODUCT TO THEIR SHOPPING CART
  
  else: # ELSE IF ANYTHING OUT OF THE ORDINARY OCCURS, IT'LL JUST PASS 
    pass

  return render_template("TheRiceMachine.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray) # THIS IS TO SEND THE RICE MACHINE PRODUCT HTML PAGE TO THE FRONTEND, WITH THE DETAILS OF THE PRODUCT FOR THE CONSUMER TO SEE
# [===] [===] #

# [===] THE BUFFALO [===] #
@app.route("/TheBuffalo", methods=["POST", "GET"]) # THIS ENSURES THAT THE PRODUCT THE BUFFALO ACCEPTS BOTH POST AND GET REQUESTS FROM THE USER
def TheBuffalo(): # THIS IS A SUBROUTINE CALLED THE BUFFALO SO THAT IF ANY USERS ARE ON THE PRODUCT PAGE, IT'LL DIRECT THEM TO THIS CODE
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=2") # SELECT THE PRODUCT'S PRICE, STOCK, SHIPPING, CAPACITY, COLOUR, VERSION AND DESCRIPTION FROM THE TABLE WHERE THE PRODUCT ID IS 2, TO BE ABLE TO GET THE PRODUCT DETAILS FOR THE PRODUCT THE BUFFALO
  for x in cursor.fetchall(): # FOR LOOPING THROUGH ALL OF THIS INFORMATION AND ASSIGNING IT AS AN ARRAY TO THE VARIABLE PRODUCT 2 INFORMATION, TO BE USED LATER ON
    Product2Information = x

  global ProductPrice # GLOBALISING ALL OF THE VARIABLES THAT HOLDS THE PRODUCT THE BUFFALO DETAILS TO BE USED LATER ON 
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription
  
  ProductPrice = Product2Information[0] # RECEIVE THE BUFFALO'S PRICE BY INDEXING THE ARRAY BY 0
  ProductStock = Product2Information[1] # RECEIVE THE BUFFALO'S STOCK BY INDEXING THE ARRAY BY 1
  if Product2Information[2] == 0: # RECEIVE THE BUFFALO'S SHIPPING COSTS BY INDEXING THE ARRAY BY 2
    ProductShipping = "Free" # IF THE COSTS ARE 0, THAN THE SHIPPING IS SET AS FREE
  else: # ELSE, THE SHIPPING COSTS IS SET TO WHATEVER INTEGER/PRICE IS STORED IN THE TABLE, USING INDEX 2
    ProductShipping = Product2Information[2]
    ProductShipping = str(ProductShipping) # DATA CONVERTING THE SHIPPING COST AS A STRING AND THEN CONCATENATING THE POUND SYMBOL IN FRONT OF IT
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product2Information[3] # RECEIVING THE PRODUCT'S CAPACITY NUMBER BY INDEXING THE ARRAY BY 3
  ProductColour = Product2Information[4] # RECEIVING THE PRODUCT'S COLOUR BY INDEXING THE ARRAY BY 4
  ProductVersion = Product2Information[5] # RECEIVING THE PRODUCT'S VERSION BY INDEXING THE ARRAY BY 5
  ProductDescription = Product2Information[6] # RECEIVING THE PRODUCT'S DESCRIPTION BY INDEXING THE ARRAY BY 6
  
  ProductPrice = str(ProductPrice) # DATA CONVERT TYPE THE PRODUCT PRICE AS A STRING AND THEN CONCATENATE A POUND SYMBOL IN FRONT
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity) # DATA CONVERT TYPE THE PRODUCT CAPACITY AS A STRING

  ReviewsArray = [] # AN ARRAY TO STORE THE REVIEWS OF THIS PRODUCT

  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 2 AND tblReviews.ProductID = 2") # SELECTING THIS PRODUCT'S REVIEWS FROM THE REVIEW TABLE, USING PRODUCT ID 2 TO ENSURE THAT THE REVIEWS ARE FOR THE BUFFALO
  for x in cursor.fetchall(): # FOR LOOPING THROUGHOUT ALL OF THE REVIEWS AND APPENDING IT TO THE REVIEWS ARRAY
    ReviewsArray.append(x[0]) # ENSURING TO INDEX IT BY 0, TO ENSURE THAT THE REVIEW ISN'T IN THE ('  '), FORMAT

  for x in ReviewsArray: # FOR LOOPING THROUGHOUT THE ARRAY THAT CONTAINS ALL OF THE REVIEWS
    if x.isspace(): # IF ANY OF THE REVIEWS ARE JUST BLANK SPACE, IT IS REMOVED FROM THE ARRAY
      ReviewsArray.remove(x)

    else: # ELSE IF ANY OF THE REVIEWS ARE STRINGS, IT'LL CONTINUE ON
      pass

  if request.method == "POST" and "NewReview" in request.form: # THIS IF STATEMENT IS HERE TO CHECK IF THE USER HAS SENT A POST REQUEST WHICH IS A REVIEW
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN VIA SESSION DATA
      NewReview = request.form["NewReview"] # RECEIVE THE REVIEW FROM REQUEST FORM

      # CHECKING IF THE REVIEW IS WHITE SPACE, IF IT IS, IT SENDS BACK THE BUFFALO HTML PAGE WITH THIS ERROR MESSAGE
      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.":
        ErrorMessage = ("Reviews can't just be white space.")
        return render_template("TheBuffalo.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)

      else:
        pass

      # IF THE REVIEW ISN'T WHITE SPACE AND HAD SOMETHING ENTERED IN, WE RECEIVE THE USERNAME FROM SESSION DATA AND CONCATENATE TO THE REVIEW
      Username = session["Username"]

      NewReview = (NewReview + " - " + Username)

      # THIS REVIEW IS THEN INSERTED INTO THE TABLE REVIEWS WITH PRODUCT ID 2 SO IT BELONGS TO THE BUFFALO
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 2)", [NewReview])
      db.commit()

    else: # ELSE ERROR MESSAGE THAT THE USER WAS SUPPOSED TO LOGIN TO TYPE UP A REVIEW AND WILL RECEIVE THE BUFFALO HTML PAGE
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("TheBuffalo.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)
    
  elif request.method == "POST": # THIS POST METHOD IS FOR WHEN THE USER IS CLICKING ON THE ADD TO CART BUTTON
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      UserEmail = session["Email"] # USER'S EMAIL IS TAKEN FROM SESSION DATA AND AN ARRAY IS CREATED

      CartEmails = []

      cursor.execute("SELECT Email FROM tblAddToCart") # PUT ALL THE EMAILS FROM THE ADD TO CART TABLE INTO THIS ARRAY
      for x in cursor.fetchall():
        CartEmails.append(x[0])

      if UserEmail in CartEmails: # IF THE USER'S EMAIL IS IN THE ARRAY THAN EMAILINCART IS SET TO TRUE, ELSE IT'S SET TO FALSE
        EmailInCart = True

      else:
        EmailInCart = False

      if EmailInCart == True: # IF EMAIL IS TRUE, THAN IT'LL SELECT THE USER'S CURRENT NUMBER OF ORDER FOR THE BUFFALO
        cursor.execute("Select TheBuffalo FROM tblAddToCart WHERE Email=?", (UserEmail,))

        for x in cursor.fetchall():
          TheBuffalo = x

        TheBuffaloNumber = TheBuffalo[0] # AFTER SELECTING THE USER'S CURRENT ORDER OF THE BUFFALO, IT'LL BECOME AN INTEGER AND GET INCREMENTED

        try:
          TheBuffaloNumber = int(TheBuffaloNumber)
        except:
          TheBuffaloNumber = 0 # ELSE IT'LL BE 0 IF IT DOESN'T EXIST
          TheBuffaloNumber = int(TheBuffaloNumber)
          
        TheBuffaloNumber += 1 # WILL THEN BE DATA CONVERTED INTO A STRING
        TheBuffaloNumber = str(TheBuffaloNumber)

        cursor.execute("UPDATE tblAddToCart SET TheBuffalo = ? WHERE Email=?", (TheBuffaloNumber, UserEmail))
        db.commit() # THE NEW INCREMENTED ORDER OF THE BUFFALO IS UPDATED IN THE ADD TO CART TABLE SO ITS NOW RECOGNISED THAT THE USER HAS AN EXTRA ORDER OF IT

      elif EmailInCart == False: # ELSE IT'LL BE INSERTED AS 1 AS THIS SHALL BE THEIR FIRST ORDER
          cursor.execute("INSERT INTO tblAddToCart (Email, TheBuffalo) VALUES (?, ?)", (UserEmail, 1))
          db.commit()

    else: # ELSE IF THEY'RE NOT LOGGED IN, AN ERROR MESSAGE IS SENT TO THE FRONTEND TO LOGIN TO BE ABLE TO ORDER PRODUCTS
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("TheBuffalo.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray)
  
  else: # ELSE, EVERYTHING IS PASS AND THE USER RECEIVES THE BUFFALO HTML PAGE WHEN NEEDED
    pass

  return render_template("TheBuffalo.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray)

# [===] [===]#

# [===] THE UNCLE JOHN [===] #
@app.route("/TheUncleJohn", methods=["POST", "GET"]) # THIS IS ESTABLISHING THE UNCLE JOHN PRODUCT PAGE AS A POST AND GET REQUEST APP ROUTE
def TheUncleJohn(): # THIS IS CREATING THE SUBROUTINE FOR THE UNCLE JOHN
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=3")
  for x in cursor.fetchall():
    Product3Information = x # SELECTING ALL OF THE PRODUCT'S INFORMATION AND ASSIGNING IT INTO THIS VARIABLE

  # ALL OF THE PRODUCT'S INFORMATION AS VARIABLES ARE GLOBALISED FOR LATER ON USAGE
  global ProductPrice
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription

  # ALL OF THE PRODUCT'S INFORMATION AS VARIABLES IS SET TO THEIR VALUE VIA INDEXING THE VARIABLE THAT HOLDS ALL OF THE PRODUCTS INFORMATION
  ProductPrice = Product3Information[0]
  ProductStock = Product3Information[1]
  if Product3Information[2] == 0:
    ProductShipping = "Free"
  else:
    ProductShipping = Product3Information[2]
    ProductShipping = str(ProductShipping)
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product3Information[3]
  ProductColour = Product3Information[4]
  ProductVersion = Product3Information[5]
  ProductDescription = Product3Information[6]

  # AFTER THE PRODUCT VARIABLES RECEIVE THEIR RESPECTIVE INFORMATION, SOME ARE CONVERTED AS A STRING AND HAVE A POUND SYMBOL CONCATENATED TO IT
  ProductPrice = str(ProductPrice)
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity)

  # AN ARRAY FOR REVIEWS IS SET UP
  ReviewsArray = []

  # SELECTING ALL OF THE REVIEWS FROM THE UNCLE JOHN PRODUCT AND ASSIGNING IT INTO THE REVIEWS ARRAY ARRAY
  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 3 AND tblReviews.ProductID = 3")
  for x in cursor.fetchall():
    ReviewsArray.append(x[0])

  # A REGULAR EXPRESSION PATTERN IS CREATED TO REMOVE ANY REVIEWS WHICH IS JUST WHITE SPACE FROM THE ARRAY
  pattern = '^[a-zA-Z0-9]'

  for x in ReviewsArray:
    if x.isspace():
      ReviewsArray.remove(x)

    else:
      pass

  # IF STATEMENT TO CHECK IF THE USER HAS SENT A POST REQUEST IN REGARDS OF SENDING IN A REVIEW FOR THE PRODUCT
  if request.method == "POST" and "NewReview" in request.form:
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      NewReview = request.form["NewReview"] # FETCHING THE REVIEW THAT THE USER HAS SENT AND ASSIGNING IT INTO THIS VARIABLE VIA REQUEST FORMS

      # IF THE REVIEW IS JUST WHITE SPACE OR THE DEFAULT TEXT MESSAGE, THAN IT'LL SEND BACK THE UNCLE JOHN HTML PAGE WITH AN ERROR MESSAGE
      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.":
        ErrorMessage = ("Reviews can't just be white space.")
        return render_template("TheUncleJohn.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)

      else:
        pass

      # RECEIVING THE USER'S USERNAME VIA SESSION DATA AND CONCATENATING TO THE REVIEW THAT THEY SENT
      Username = session["Username"]

      NewReview = (NewReview + " - " + Username)

      # INSERTING THIS REVIEW TO THE TABLE OF REVIEWS FOR PRODUCT 3, SO THIS NEW REVIEW BELONG TO THIS SPECIFIC PRODUCT
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 3)", [NewReview])
      db.commit()

    else: # ELSE, THE USER NEED TO LOGIN TO THEIR ACCOUNT TO BE ABLE TO SEND IN A REVIEW AND WILL RECEIVE THE UNCLE JOHN HTML PRODUCT PAGE
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("TheUncleJohn.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)
    
  elif request.method == "POST": # IF THE NEXT REQUEST IS JUST POST, THIS MEANS THEY'RE ADDING A CART TO THEIR ADD TO CART BASKET
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      UserEmail = session["Email"] # RECEIVING THE USER'S EMAIL VIA SESSION DATA

      CartEmails = [] # AN ARRAY IS CREATED TO HOLD EMAILS

      cursor.execute("SELECT Email FROM tblAddToCart") # APPEND ALL OF THE EMAILS THAT HAVE A SHOPPING CART TO THIS ARRAY
      for x in cursor.fetchall():
        CartEmails.append(x[0])

      if UserEmail in CartEmails: # IF THE USER'S EMAIL IS IN THERE, THAN EMAILINCART IS SET TO TRUE, ELSE IT'LL SET TO FALSE
        EmailInCart = True

      else:
        EmailInCart = False

      if EmailInCart == True: # IF EMAIL IN CART IS SET TO TRUE, THAN IT'LL RECEIVE THE CURRENT NUMBER OF UNCLE JOHN ORDERS THEY'VE WISHLISTED
        cursor.execute("Select TheUncleJohn FROM tblAddToCart WHERE Email=?", (UserEmail,))

        for x in cursor.fetchall():
          TheUncleJohn = x

        TheUncleJohnNumber = TheUncleJohn[0] # DONE BY THIS INDEX

        try:
          TheUncleJohnNumber = int(TheUncleJohnNumber)
        except:
          TheUncleJohnNumber = 0
          TheUncleJohnNumber = int(TheUncleJohnNumber)

        # THE ORDER OF UNCLE JOHNS IS DATA CONVERTED INTO AN INTEGER AND THEN INCREMENTED, AND THEN DATA CONVERTED BACK TO A STRING
        TheUncleJohnNumber += 1
        TheUncleJohnNumber = str(TheUncleJohnNumber)

        cursor.execute("UPDATE tblAddToCart SET TheUncleJohn = ? WHERE Email=?", (TheUncleJohnNumber, UserEmail))
        db.commit() # THE NEW ORDER OF UNCLE JOHNS IS UPDATED TO THE TABLE ADD TO CART, TO RECOGNISE THAT THE USER HAVE WISHLISTED A NEW PRODUCT

      elif EmailInCart == False: # IF EMAILINCART IS FALSE, THAN IT'LL INSERT THE UNCLE JOHN ORDER AS 1, ALONGSIDE THEIR USEREMAIL TO CREATE A SHOPPING CART FOR THEM
          cursor.execute("INSERT INTO tblAddToCart (Email, TheUncleJohn) VALUES (?, ?)", (UserEmail, 1))
          db.commit()

    else: # ELSE AN ERROR MESSAGE IS CREATED AND SENT TO THE FRONTEND FROM THE UNCLE JOHN HTML PAGE WITH THE ERROR TO LOGIN TO BE ABLE TO ORDER PRODUCTS
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("TheUncleJohn.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray)
  
  else: # ELSE, THE USER WILL JUST RECEIVE THE UNCLE JOHN HTML PRODUCT PAGE
    pass

  return render_template("TheUncleJohn.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray)
# [===] [===] #

# [===] RICE AND DICE [===] #
@app.route("/RiceAndDice", methods=["POST", "GET"]) # A POST AND GET REQUEST APP ROUTE IS CREATED FOR THE RICE AND DICE
def RiceAndDice(): # SUBROUTINE IS CREATED FOR THE RICE AND DICE
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=4")
  for x in cursor.fetchall(): # ALL OF THE PRODUCT INFORMATION IS SELECTED AND ASSIGNED TO THIS VARIABLE
    Product4Information = x

  # ALL OF THE PRODUCT'S INFORMATION VARIABLE IS GLOBALISED
  global ProductPrice
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription

  # ALL OF THE PRODUCT VARIABLE GETS THEIR RESPECTIVE INFORMATION VIA INDEXING 
  ProductPrice = Product4Information[0]
  ProductStock = Product4Information[1]
  if Product4Information[2] == 0:
    ProductShipping = "Free"
  else:
    ProductShipping = Product4Information[2]
    ProductShipping = str(ProductShipping)
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product4Information[3]
  ProductColour = Product4Information[4]
  ProductVersion = Product4Information[5]
  ProductDescription = Product4Information[6]

  # THE PRODUCT VARIABLES ARE DATA CONVERTED AS A STRING AND HAVE A POUND SYMBOL CONCATENATED TO THEM 
  ProductPrice = str(ProductPrice)
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity)

  # AN ARRAY IS CREATED FOR THE REVIEWS
  ReviewsArray = []

  # ALL OF THE REVIEWS ARE SELECTED FOR THIS SPECIFIC PRODUCT AND APPENDED TO THE REVIEWS ARRAY ARRAY
  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 4 AND tblReviews.ProductID = 4")
  for x in cursor.fetchall():
    ReviewsArray.append(x[0])

  # A REGULAR EXPRESSION PATTERN IS CREATED TO CHECK IF ANY OF THE REVIEWS SELECTED IS JUST WHITE SPACE, IF IT IS, IT'S REMOVED FROM THE ARRAY
  pattern = '^[a-zA-Z0-9]'

  for x in ReviewsArray:
    if x.isspace():
      ReviewsArray.remove(x)

    else:
      pass

  # IF STATEMENT TO CHECK IF THE USER HAS SENT A REVIEW VIA A POST REQUEST
  if request.method == "POST" and "NewReview" in request.form:
    if "Username" in session and "Password" in session and "Email" in session: # THAN CHECKING IF THE USER IS LOGGED IN
      NewReview = request.form["NewReview"] # NEW REVIEW IS FETCHED FROM REQUEST FORMS, FROM THE FRONTEND

      # IF STATEMENT TO CHECK IF THE REVIEW SENT IS JUST WHITE SPACE OR THE DEFAULT MESSAGE, IF IT IS, THAN IT'LL SEND BACK THE RICE AND DICE PRODUCT PAGE WITH AN ERROR MESSAGE
      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.":
        ErrorMessage = ("Reviews can't just be white space.")
        
        return render_template("RiceAndDice.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)

      else:
        pass

      # THE USER'S USERNAME IS SELECTED FROM SESSION DATA USERNAME AND IS CONCATENATED TO NEWREVIEW
      Username = session["Username"]

      NewReview = (NewReview + " - " + Username)

      # THE REVIEW THAT THE USER SENT IS INSERTED TO THE TABLE OF REVIEWS FOR THIS SPECIFIC PRODUCT NUMBER 4
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 4)", [NewReview])
      db.commit()

    else: # ELSE, THE USER WILL RECEIVE THE RICE AND DICE PRODUCT HTML PAGE WITH THIS ERROR MESSAGE IF THEY HAVEN'T LOGGED IN
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("RiceAndDice.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)
    
  elif request.method == "POST": # ANOTHER IF STATEMENT POST REQUEST, THIS TIME, THIS IS FOR WHEN THE USER IS ADDING A PRODUCT TO THEIR SHOPPING CART
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      UserEmail = session["Email"] # RECEIVING THE USER'S EMAIL FROM SESSION DATA 

      CartEmails = [] # AN ARRAY FOR CART EMAILS IS CREATED

      cursor.execute("SELECT Email FROM tblAddToCart") # SELECTING ALL THE EMAILS FROM THE ADD TO CART TABLE AND APPENDING IT TO THE ARRAY CART EMAILS
      for x in cursor.fetchall():
        CartEmails.append(x[0])

      if UserEmail in CartEmails: # IF THE USER EMAIL IS INSIDE THIS ARRAY, THAN EMAILINCART IS SET TO TRUE, ELSE IT'S SET TO FALSE
        EmailInCart = True

      else:
        EmailInCart = False

      if EmailInCart == True: # IF EMAILINCART IS TRUE, THAN THEY'LL SELECT THE USER'S CURRENT ORDER OF THE RICE AND DICE
        cursor.execute("Select RiceAndDice FROM tblAddToCart WHERE Email=?", (UserEmail,))
        for x in cursor.fetchall():
          RiceAndDice = x

        RiceAndDiceNumber = RiceAndDice[0] # AND SETTING IT TO THIS VARIABLE VIA INDEXING

        # THE CURRENT ORDER OF THE RICE AND DICE IS THEN DATA CONVERTED INTO AN INTEGER AND THEN INCREMENTED
        try:
          RiceAndDiceNumber = int(RiceAndDiceNumber)
        except:
          RiceAndDiceNumber = 0
          RiceAndDiceNumber = int(RiceAndDiceNumber)
          
        RiceAndDiceNumber += 1
        # THE RICE AND DICE IS THAN DATA CONVERTED BACK TO A STRING, TO UPDATE IT IN THE TABLE ADD TO CART, TO RECOGNISE THAT THE USER HAS ADDED A NEW PRODUCT
        RiceAndDiceNumber = str(RiceAndDiceNumber)

        cursor.execute("UPDATE tblAddToCart SET RiceAndDice = ? WHERE Email=?", (RiceAndDiceNumber, UserEmail))
        db.commit()

      elif EmailInCart == False: # ELSE, IT'LL INSERT THE RICE AND DICE ORDER AS 1 AND CREATING A SHOPPING CART FOR THE USER WITH THEIR EMAIL
          cursor.execute("INSERT INTO tblAddToCart (Email, RiceAndDice) VALUES (?, ?)", (UserEmail, 1))
          db.commit()

    else: # ELSE, THE USER WILL RECEIVE THE RICE AND DICE HTML PRODUCT PAGE WITH THE ERROR MESSAGE THAT THEY NEED TO LOGIN TO BE ABLE TO ORDER PRODUCTS
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("RiceAndDice.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray)
  
  else: # ELSE THE USER WILL RECEIVE THE RICE AND DICE HTML PRODUCT PAGE WITH ALL OF THE INFORMATION ASSIGNED TO IT VIA HTML VARIABLES
    pass

  return render_template("RiceAndDice.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray)
# [===] [===] #

# [===] THE BASMATI BOILER [===] #
@app.route("/TheBasmatiBoiler", methods=["POST", "GET"]) # AN POST AND GET METHOD APP ROUTE IS CREATED FOR THE BASMATI BOILER
def TheBasmatiBoiler(): # A SUBROUTINE IS CREATED FOR THE BASMATI BOILER
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=5")
  for x in cursor.fetchall(): # SELECTING ALL OF THE PRODUCTS INFORMATION AND ASSIGNING IT INTO THIS VARIABLE
    Product5Information = x

  # GLOBALISE ALL OF THE PRODUCT'S INFORMATION VARIABLES TO BE USED LATER ON
  global ProductPrice
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription

  # ALL OF THE PRODUCT'S VARIABLES IS ASSIGNED THEIR RESPECTIVE PRODUCT INFORMATION VIA THE USAGE OF INDEXING
  ProductPrice = Product5Information[0]
  ProductStock = Product5Information[1]
  if Product5Information[2] == 0:
    ProductShipping = "Free"
  else:
    ProductShipping = Product5Information[2]
    ProductShipping = str(ProductShipping)
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product5Information[3]
  ProductColour = Product5Information[4]
  ProductVersion = Product5Information[5]
  ProductDescription = Product5Information[6]

  # AFTER THIS, THE PRODUCT'S INFORMATION VARIABLES ARE DATA CONVERTED INTO A STRING AND HAVE A POUND SYMBOL CONCATENATED TO IT
  ProductPrice = str(ProductPrice)
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity)

  # AN ARRAY TO HOLD THE REVIEWS IS CREATED
  ReviewsArray = []

  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 5 AND tblReviews.ProductID = 5")
  for x in cursor.fetchall(): # ALL OF THE REVIEWS FOR THIS PRODUCT IS SELECTED AND APPENDED TO THE REVIEWS ARRAY
    ReviewsArray.append(x[0])

  pattern = '^[a-zA-Z0-9]' # A REGULAR EXPRESSION PATTERN IS CREATED TO CHECK IF ANY OF THE REVIEWS IS JUST WHITE SPACE OR NOT, IF IT IS THAN IT'LL BE REMOVED FROM THE ARRAY

  for x in ReviewsArray:
    if x.isspace():
      ReviewsArray.remove(x)

    else:
      pass

  # IF STATEMENT TO CHECK IF THE USER HAS SENT A POST REQUEST WHICH IS TYPING UP A NEW REVIEW
  if request.method == "POST" and "NewReview" in request.form:
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      NewReview = request.form["NewReview"] # RECEIVING THE USER'S REVIEW VIA REQUEST FORMS

      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.":
        ErrorMessage = ("Reviews can't just be white space.") # IF THE REVIEW IS JUST WHITE SPACE OR THE DEFAULT MESSAGE, IT'LL RETURN THE BASMATI BOILER HTML PAGE WITH THIS ERROR MESSAGE
        
        return render_template("TheBasmatiBoiler.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)

      else:
        pass

      # USER'S USERNAME IS RECEIVED VIA SESSION DATA AND THEN CONCATENATED TO THE REVIEW THAT THE USER HAS SENT, WHICH IS INSERTED INTO THE TABLE OF REVIEWS FOR THIS SPECIFIC PRODUCT
      Username = session["Username"]

      NewReview = (NewReview + " - " + Username)
    
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 5)", [NewReview])
      db.commit()

    else: # ELSE, THE ERROR MESSAGE WILL BE CREATED AND WILL BE SENT TO THE BASMATI BOILER HTML PRODUCT PAGE THAT THE USER NEED TO LOGIN TO BE ABLE TO TYPE UP A REVIEW
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("TheBasmatiBoiler.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)
    
  elif request.method == "POST": # CHECKING IF THERE'S ANOTHER POST REQUEST METHOD, WHICH THIS TIME, SHOULD BE THE USER ADDING A PRODUCT TO THEIR CART
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      UserEmail = session["Email"] # RECEIVING THE USER'S EMAIL FROM SESSION DATA

      CartEmails = [] # AN ARRAY IS CREATED TO HOLD THE EMAILS WHICH HAS A SHOPPING CART

      cursor.execute("SELECT Email FROM tblAddToCart") # DONE BY SELECTING ALL EMAILS FROM TBL ADD TO CART AND APPENDING IT TO THIS ARRAY
      for x in cursor.fetchall():
        CartEmails.append(x[0])

      if UserEmail in CartEmails: # IF THE USER'S EMAIL IS IN THIS ARRAY, EMAILINCART WILL BE SET TO TRUE, ELSE IT'LL BE SET TO FALSE
        EmailInCart = True

      else:
        EmailInCart = False

      if EmailInCart == True: # IF EMAILINCART IS SET TO TRUE, THAN IT'LL RECEIVE THE USER'S CURRENT ORDER OF THE BASMATI BOILER
        cursor.execute("Select TheBasmatiBoiler FROM tblAddToCart WHERE Email=?", (UserEmail,))
        for x in cursor.fetchall():
          TheBasmatiBoiler = x

        TheBasmatiBoilerNumber = TheBasmatiBoiler[0]

        # IT'LL DATA CONVERT TYPE THE ORDER OF THE BASMATI BOILER INTO AN INTEGER AND THEN INCREMENT IT, ALONGSIDE DATA CONVERT IT BACK TO A STRING
        try:
          TheBasmatiBoilerNumber = int(TheBasmatiBoilerNumber)
        except:
          TheBasmatiBoilerNumber = 0
          TheBasmatiBoilerNumber = int(TheBasmatiBoilerNumber)

        TheBasmatiBoilerNumber += 1
        TheBasmatiBoilerNumber = str(TheBasmatiBoilerNumber)

        # THIS IS THEN UPDATED IN THE TBL ADD TO CART, TO RECOGNISE THAT THE USER HAS ORDERED ANOTHER PRODUCT OF THE BASMATI BOILER
        cursor.execute("UPDATE tblAddToCart SET TheBasmatiBoiler = ? WHERE Email=?", (TheBasmatiBoilerNumber, UserEmail))
        db.commit()

      elif EmailInCart == False: # ELSE, THEIR ORDER WILL BE INSERTED AS 1 AND A SHOPPING CART WILL BE CREATED FOR THEM
          cursor.execute("INSERT INTO tblAddToCart (Email, TheBasmatiBoiler) VALUES (?, ?)", (UserEmail, 1))
          db.commit()

    else: # AN ERROR MESSAGE IS CREATED AND SENT TO THE FRONTEND IF THE USER NEEDS TO LOGIN TO BE ABLE TO ORDER PRODUCTS
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("TheBasmatiBoiler.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray)
  
  else: # ELSE, THE USER WILL RECEIVE THE BASMATI BOILER HTML PRODUCT PAGE WITH ALL OF THE INFORMATION ABOUT THE PRODUCT VIA HTML VARIABLES
    pass

  return render_template("TheBasmatiBoiler.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray)
# [===] [===] #

# [===] RICE COOKER 3000 [===] #
@app.route("/RiceCooker3000", methods=["POST", "GET"]) # AN APP ROUTE WITH POST AND GET REQUEST METHODS IS CREATED FOR THE RICE COOKER 3000
def RiceCooker3000(): # A SUBROUTINE FOR THE RICE COOKER 300O IS CREATED
  cursor.execute("SELECT ProductPrice, ProductStock, ProductShipping, ProductCapacity, ProductColour, ProductVersion, ProductDescription FROM tblProducts WHERE ProductID=6")
  for x in cursor.fetchall(): # ALL OF THE PRODUCT INFORMATION FOR THE RICE COOKER 3000 IS SELECTED AND ASSIGNED TO THIS VARIABLE
    Product6Information = x

  # ALL OF THE PRODUCT'S VARIABLES IS GLOBALISED
  global ProductPrice
  global ProductStock
  global ProductShipping
  global ProductCapacity
  global ProductColour
  global ProductVersion
  global ProductDescription

  # ALL OF THE PRODUCT'S VARIABLES IS ASSIGNED THEIR RESPECTIVE INFORMATION VIA THE USAGE OF INDEXING
  ProductPrice = Product6Information[0]
  ProductStock = Product6Information[1]
  if Product6Information[2] == 0:
    ProductShipping = "Free"
  else:
    ProductShipping = Product6Information[2]
    ProductShipping = str(ProductShipping)
    ProductShipping = ("£" + ProductShipping)
  ProductCapacity = Product6Information[3]
  ProductColour = Product6Information[4]
  ProductVersion = Product6Information[5]
  ProductDescription = Product6Information[6]

  # THE PRODUCT'S VARIABLE IS THEN DATA CONVERTED INTO A STRING WITH A POUND SYMBOL CONCATENATED INFRONT OF IT
  ProductPrice = str(ProductPrice)
  ProductPrice = ("£" + ProductPrice)
  ProductCapacity = str(ProductCapacity)

  # AN ARRAY TO HOLD THE REVIEWS OF THIS PRODUCT IS CREATED
  ReviewsArray = []

  # SELECTING ALL OF THE REVIEWS FROM THIS TABLE FOR THIS PRODUCT AND ASSIGNING IT TO THE REVIEWS ARRAY ARRAY
  cursor.execute("SELECT Review FROM tblReviews, tblProducts WHERE tblProducts.ProductID = tblReviews.ProductID AND tblProducts.ProductID = 6 AND tblReviews.ProductID = 6")
  for x in cursor.fetchall():
    ReviewsArray.append(x[0])

  # A REGULAR EXPRESSION PATTERN IS CREATED TO CHECK IF ANY OF THE REVIEWS IS JUST WHITE SPACE, IF IT IS, THEN IT'LL BE REMOVED FROM THE ARRAY
  pattern = '^[a-zA-Z0-9]'

  for x in ReviewsArray:
    if x.isspace():
      ReviewsArray.remove(x)

    else:
      pass

  # IF STATEMENT TO CHECK IF THE USER SENT IN A REVIEW AS A POST REQUEST
  if request.method == "POST" and "NewReview" in request.form:
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      NewReview = request.form["NewReview"] # THE USER'S REVIEW IS RECEIVED VIA REQUEST FORMS
      
      # CHECKING IF THE USER'S REVIEW IS WHITE SPACE, IF IT IS, THAN IT'LL SEND AN ERROR MESSAGE TO THE FRONTEND THAT THE REVIEW CANNOT JUST BE WHITE SPACE
      if NewReview.isspace() or len(NewReview) == 0 or NewReview == "Reviews can't just be white space.":
        ErrorMessage = ("Reviews can't just be white space.")
        
        return render_template("RiceCooker3000.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)

      else:
        pass

      # USER'S USERNAME IS FETCHED VIA SESSION DATA AND THEN IS CONCATENATED TO THE REVIEW THAT THEY SENT, WHICH IS THEN INSERTED TO THE TABLE OF REVIEWS FOR THIS PRODUCT
      Username = session["Username"]

      NewReview = (NewReview + " - " + Username)
    
      cursor.execute("INSERT INTO tblReviews (Review, ProductID) VALUES (?, 6)", [NewReview])
      db.commit()

    else: # AN ERROR MESSAGE IS SENT TO THE FRONTEND VIA A HTML VARIABLE TO INFORM THE USER THAT THEY NEED TO LOGIN TO BE ABLE TO TYPE UP A REVIEW
      ErrorMessage = ("Please login to your account if you wish to type up a review.")
      
      return render_template("RiceCooker3000.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, ReviewErrorMessage=ErrorMessage, CurrentReview=ReviewsArray)
    
  elif request.method == "POST": # CHECKING IF THE USER SENT IN A POST REQUEST, WHICH WILL BE THEM TRYING TO ADD A PRODUCT TO THEIR SHOPPING CART
    if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN OR NOT
      UserEmail = session["Email"] # RECEIVING THE USER'S EMAIL FROM SESSION DATA

      CartEmails = [] # AN ARRAY IS CREATED TO STORE ALL OF THE EMAILS FROM THE CURRENT TABLE ADD TO CART

      # SELECTING ALL OF THE EMAIL FROM TBL ADD TO CART AND APPENDING IT INTO THE ARRAY CART EMAILS
      cursor.execute("SELECT Email FROM tblAddToCart")
      for x in cursor.fetchall():
        CartEmails.append(x[0])

      if UserEmail in CartEmails: # IF THE USER'S EMAIL IS INSIDE THIS ARRAY, THAN EMAILINCART IS SET TO TRUE, ELSE, IT'S SET TO FALSE
        EmailInCart = True  

      else:
        EmailInCart = False

      if EmailInCart == True: # IF EMAILINCART IS SET TO TRUE, THAN IT'LL RECEIVE THE CURRENT NUMBER OF ORDERS OF RICE COOKER 3000S THEY HAVE
        cursor.execute("Select RiceCooker3000 FROM tblAddToCart WHERE Email=?", (UserEmail,))

        for x in cursor.fetchall():
          RiceCooker3000 = x

        RiceCooker3000Number = RiceCooker3000[0]

        # THIS VARIABLE IS THEN DATA CONVERTED TO AN INTEGER AND INCREMENTED AND THAN DATA CONVERTED BACK TO A STRING  
        try:
          RiceCooker3000Number = int(RiceCooker3000Number)
        except:
          RiceCooker3000Number = 0
          RiceCooker3000Number = int(RiceCooker3000Number)

        RiceCooker3000Number += 1
        RiceCooker3000Number = str(RiceCooker3000Number)

        # THE NEW ORDER OF RICE COOKER 3000S IS UPDATED IN THE TABLE ADD TO CART TO RECOGNISE THAT THE USER HAS ORDERED ANOTHER PRODUCT
        cursor.execute("UPDATE tblAddToCart SET RiceCooker3000 = ? WHERE Email=?", (RiceCooker3000Number, UserEmail))
        db.commit()

      elif EmailInCart == False: # IF EMAILINCART IS FALSE, THAN A SHOPPING CART IS CREATED, WITH RICE COOKER 3000 INSERTED AS 1
          cursor.execute("INSERT INTO tblAddToCart (Email, RiceCooker3000) VALUES (?, ?)", (UserEmail, 1))
          db.commit()

    else: # ELSE, THE USER WILL RECEIVE THE ERROR MESSAGE THAT THEY NEED TO LOGIN TO BE ABLE TO ORDER PRODUCTS, VIA THE RICE COOKER 3000 PRODUCT HTML PAGE
      ErrorMessage = "Please log in to your account to be able to order products."
      
      return render_template("RiceCooker3000.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, Error=ErrorMessage, CurrentReview=ReviewsArray)
  
  else: # ELSE, THE USER WILL JUST RECEIVE THE RICE COOKER 3000 HTML PRODUCT PAGE WITH ALL OF THE NECESSARY PRODUCT INFORMATION
    pass

  return render_template("RiceCooker3000.html", ProductPrice=ProductPrice, ProductStock=ProductStock, ProductShipping=ProductShipping, ProductCapacity=ProductCapacity, ProductColour=ProductColour, ProductVersion=ProductVersion, DescriptionBox=ProductDescription, CurrentReview=ReviewsArray)
# [===] [===] #

# FOR THE PAYMENT PAGE NOTES
# NEED TO MAKE IT SO IT ACCESS THE RIGHT DBMS WITH THE RIGHT ROW FOR THE RIGHT PERSON (USE THEIR EMAIL ADDRESS)
# AFTER THAT, WE NEED TO CALCULATE THE PRICE (GO THROUGH THE PRODUCTS DBMS AND FIND THEIR PRICES, MULTIPLY IT BY HOW MANY OF THE PRODUCES THEY ORDERED)
# CALCULATE THE TOTAL PRICE
# SEND IT TO THE FRONTEND (TOTAL PRICE, HOW MANY OF EACH PRODUCTS THEY ORDERED, HOW MUCH THEIR VALUE IS PER PRODUCT)
# PUT POUND SIGN IN FRONT OF MONEY
# IF WE RECEIVE A DISCOUNT OFFER, WE NEED TO SEE IF THAT DISCOUNT OFFER IS A THING (DBMS)
# IF NOT SEND TO THE FRONTEND THAT IT'S WRONG, ELSE APPLY IT TO THE TOTAL PRICE AND THEN TO THE FRONTEND THAT THE CODE IS BEING USED AND HOW MUCH IT REDUCES FROM HTE TOTAL PRICE
# AND SHOW THE NEW TOTAL PRICE
# check bank details r correct
# IF THEY DO CLICK PAY, STORE THEIR BANKING DETAILS AND EVERYTHING, AND WIPE OUT THEIR CART SINCE THEY'VE PAID
# FOR LATER USE, TAKE IN TH ENUMBER OF UNITS SOLD, TOTAL REVNEUE, FREUEQNET PRODUCT, UNFREQUENT PRODUCT (KEEP A TALLY OF EACH PRODUCT BOUGHT)
  
# MAKE IT SO THEY CAN EITHER INCRAESE OR DECREASE THE PRODUCTS IN THEIR CART


# [===] PAYMENT PAGE [===] #
@app.route("/ShoppingCart", methods=["POST", "GET"]) # APP ROUTE FOR THE SHOPPING CART TO ACCEPT BOTH POST AND GET REQUESTS
def PaymentPage(): # PAYMENT PAGE SUBROUTINE
  if "Username" in session and "Password" in session and "Email" in session: # CHECKING IF THE USER IS LOGGED IN
    TotalProductShipping = 0 # TOTALPRODUCTSHIPPING LOCAL VARIABLE SET TO 0
    UserEmail = session["Email"] # RECEIVE USER'S EMAIL THROUGH SESSION DATA

    cursor.execute("SELECT Email FROM tblAddToCart") # RECEIVING A LIST OF EMAILS
    for x in cursor.fetchall():
      EmailList = x

    if UserEmail in EmailList: # IF THE USER EMAIL IS IN THE LIST, WE CAN ASSUME THEY'VE A SHOPPING CART, ELSE, THEY'LL BE SENT BACK THE HTML PAYMENT PAGE WITH EVERYTHING AS 0
      pass

    else:
      return render_template("PaymentPage.html", RiceMachineUnits=0, RiceMachinePrice="£0.0", BuffaloUnits=0, BuffaloPrice="£0.0", UncleJohnUnits=0, UncleJohnPrice="£0.0", RiceAndDiceUnits=0, RiceAndDicePrice="£0.0", BasmatiBoilerUnits=0, BasmatiBoilerPrice="£0.0", RiceCookerUnits=0, RiceCookerPrice="£0.0", TOTAL="£0.0", SHIPPING="£0.0", VAT="£0.0", PAIDAMOUNT="£0.0")
      
    # RECEIVING THE NUMBER OF ORDERS FOR EVERY PRODUCT THE USER MAY HAVE ORDERED, ASSIGNED TO LOCAL VARIABLE ARRAYWITHORDERS
    cursor.execute("SELECT TheRiceMachine, TheBuffalo, TheUncleJohn, RiceAndDice, TheBasmatiBoiler, RiceCooker3000 FROM tblAddToCart WHERE Email=?", (UserEmail,))
    for x in cursor.fetchall():
      ArrayWithOrders = x            

    #CalculatingRiceMachinePrice
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=1") # SELECTING THE PRODUCT PRICE FOR THE RICE MACHINE
    for x in cursor.fetchall():
      RiceMachinePrice = (x[0])

    RiceMachineOrders = ArrayWithOrders[0] # SELECTING THE NUMBER OF RICE MACHINE ORDERS

    try: # THIS CALCULATES THE TOTAL PRICE FOR ALL OF THE RICE MACHINES THE USER HAS ORDERED
      TotalRiceMachinePrice = RiceMachinePrice * RiceMachineOrders
    except:
      RiceMachineOrders = 0
      TotalRiceMachinePrice = RiceMachinePrice * RiceMachineOrders
              
    if RiceMachineOrders > 0: # IF THEY ORDERED MORE THAN 1 RICE MACHINE, SHIPPING COSTS ARE SET, ELSE, THE SHIPPING COST IS 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=1")
      for x in cursor.fetchall():
        ProductRiceMachineShipping = (x[0])

        if ProductRiceMachineShipping == "None":
          ProductRiceMachineShipping = 0
          
        TotalProductShipping += ProductRiceMachineShipping # RICE MACHINE'S SHIPPING COST IS ADDED TO THE TOTAL SHIPPING COSTS

    #CalculatingTheBuffaloPrice
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=2") # SELECTING THE PRODUCT PRICE WHEN THE PRODUCT IS THE BUFFALO
    for x in cursor.fetchall():
      TheBuffaloPrice = (x[0])

    TheBuffaloOrders = ArrayWithOrders[1] # RECEIVING THE NUMBER OF THE BUFFALO ORDERS

    try: # CALCULATING THE TOTAL PRICE OF ALL OF THE BUFFALO ORDERS
      TotalTheBuffaloPrice = TheBuffaloPrice * TheBuffaloOrders
    except:
      TheBuffaloOrders = 0
      TotalTheBuffaloPrice = TheBuffaloPrice * TheBuffaloOrders

    if TheBuffaloOrders > 0: # IF THERE'S ORDERS OF THE BUFFALO, SELECT THEIR SHIPPING COSTS, ELSE, THEIR SHIPPING COST IS 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=2")
      for x in cursor.fetchall():
        ProductTheBuffaloShipping = (x[0])

        if ProductTheBuffaloShipping == "None":
          ProductTheBuffaloShipping = 0
          
        TotalProductShipping += ProductTheBuffaloShipping # THE BUFFALO SHIPPING COST IS ADDED TO THE TOTAL PRODUCT SHIPPING

    #CalculatingUncleJohnPrice
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=3") # SELECTING THE PRODUCE PRICE FOR THE UNCLE JOHN
    for x in cursor.fetchall():
      UncleJohnPrice = (x[0])

    UncleJohnOrders = ArrayWithOrders[2] # SELECTING HOW MANY UNCLE JOHNS ARE ORDERED

    try: # CALCULATING THE TOTAL PRICE OF ALL OF THE UNCLE JOHNS
      TotalUncleJohnPrice = UncleJohnPrice * UncleJohnOrders
    except:
      UncleJohnOrders = 0
      TotalUncleJohnPrice = UncleJohnPrice * UncleJohnOrders

    if UncleJohnOrders > 0: # IF THEY'VE ORDERED AN UNCLE JOHN, SELECT THEIR SHIPPING COSTS, ELSE, SHIPPING COSTS ARE SET TO 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=3")
      for x in cursor.fetchall():
        ProductUncleJohnShipping = (x[0])

        if ProductUncleJohnShipping == "None":
          ProductUncleJohnShipping = 0
          
        TotalProductShipping += ProductUncleJohnShipping # ADDING THE UNCLE JOHN SHIPPING COST TO TOTAL SHIPPING COSTS

    #CalculatingRiceDicePrice
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=4") # SELECTING THE PRODUCT PRICE WHEN THE PRODUCT IS THE RICE AND DICE
    for x in cursor.fetchall():
      RiceDicePrice = (x[0])

    RiceDiceOrders = ArrayWithOrders[3] # SELECTING THE NUMBER OF ORDERS OF THE RICE AND DICE THERE IS

    try: # CALCULATING THE TOTAL PRICE FOR ALL OF THE RICE AND DICES
      TotalRiceDicePrice = RiceDicePrice * RiceDiceOrders
    except:
      RiceDiceOrders = 0
      TotalRiceDicePrice = RiceDicePrice * RiceDiceOrders

    if RiceDiceOrders > 0: # IF A RICE AND DICE BEEN ORDERED, THAN THEIR SHIPPING COST IS RECEIVED, ELSE IT'S SET TO 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=4")
      for x in cursor.fetchall():
        ProductRiceDiceShipping = (x[0])

        if ProductRiceDiceShipping == "None":
          ProductRiceDiceShipping = 0
          
        TotalProductShipping += ProductRiceDiceShipping # THE RICE AND DICE SHIPPING COSTS IS ADDED TO THE TOTAL SHIPPING COSTS

    #CalculatingBasmatiBoilerPrice
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=5") # RECEIVING THE PRODUCT PRICE FOR THE BASMATI BOILER
    for x in cursor.fetchall():
      BasmatiBoilerPrice = (x[0])

    BasmatiBoilerOrders = ArrayWithOrders[4] # RECEIVING THE NUMBER OF ORDERS OF THE BASMATI BOILER THERE IS

    try: # CALCULATING THE TOTAL PRICE OF ALL OF THE BASMATI BOILERS
      TotalBasmatiBoilerPrice = BasmatiBoilerPrice * BasmatiBoilerOrders
    except:
      BasmatiBoilerOrders = 0
      TotalBasmatiBoilerPrice = BasmatiBoilerPrice * BasmatiBoilerOrders

    if BasmatiBoilerOrders > 0: # IF THERE ARE BASMATI BOILERS, THEIR SHIPPING COST IS FETCHED, ELSE, IT'S SET TO 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=5")
      for x in cursor.fetchall():
        ProductBasmatiBoilerShipping = (x[0])

        if ProductBasmatiBoilerShipping == "None":
          ProductBasmatiBoilerShipping = 0
          
        TotalProductShipping += ProductBasmatiBoilerShipping # THE BASMATI BOILER SHIPPING COSTS IS ADDED TO TOTAL PRODUCT SHIPPING

    #CalculatingCooker3000Price
    cursor.execute("SELECT ProductPrice FROM tblProducts WHERE ProductID=6") # SELECTING THE PRODUCT PRICE FOR THE RICE COOKER 3000
    for x in cursor.fetchall():
      Cooker3000Price = (x[0])

    Cooker3000Orders = ArrayWithOrders[5] # RECEIVING THE NUMBER OF RICE COOKER 3000 ORDERS

    try: # CALCULATING THE TOTAL COSTS OF THE RICE COOKER 3000S
      TotalCooker3000Price = Cooker3000Price * Cooker3000Orders
    except:
      Cooker3000Orders = 0
      TotalCooker3000Price = Cooker3000Price * Cooker3000Orders

    if Cooker3000Orders > 0: # IF A RICE COOKER 3000 HAVE BEEN ORDERED, THEIR SHIPPING COSTS IS SET, ELSE IT'S 0
      cursor.execute("SELECT ProductShipping FROM tblProducts WHERE ProductID=6")
      for x in cursor.fetchall():
        ProductCooker3000Shipping = (x[0])

        if ProductCooker3000Shipping == "None":
          ProductCooker3000Shipping = 0
          
        TotalProductShipping += ProductCooker3000Shipping # RICE COOKER 3000'S SHIPPING COSTS IS ADDED TO TOTAL PRODUCT SHIPPING

    # GETTING TOTAL PRICE

    TotalRiceMachinePrice = round(TotalRiceMachinePrice, 2) # ROUNDING ALL OF THE PRODUCTS TOTAL COSTS TO 2 DECIMALS
    TotalTheBuffaloPrice = round(TotalTheBuffaloPrice, 2)
    TotalUncleJohnPrice = round(TotalUncleJohnPrice, 2)
    TotalRiceDicePrice = round(TotalRiceDicePrice, 2)
    TotalBasmatiBoilerPrice = round(TotalBasmatiBoilerPrice, 2)
    TotalCooker3000Price = round(TotalCooker3000Price, 2)

    OverallTotalCost = TotalRiceMachinePrice + TotalTheBuffaloPrice + TotalUncleJohnPrice + TotalRiceDicePrice + TotalBasmatiBoilerPrice + TotalCooker3000Price # CALCULATING THE OVERALL COSTS BY ADDING ALL OF THE PRODUCT'S TOTAL COSTS

    OverallTotalCost = round(OverallTotalCost, 2) # ROUNDING THE TOTAL SHIPPING AND OVERALL COSTS BY 2 DECIMAL PLACES
    TotalProductShipping = round(TotalProductShipping, 2)

    VAT = OverallTotalCost + TotalProductShipping # CREATING VAT BY ADDING PRODUCT AND SHIPPING COSTS AND RECIVING 20% OF IT, ROUNDING IT TO 2 DECIMALS
    VAT = round(VAT, 2)
    VAT = VAT * 0.2
    VAT = round(VAT, 2)

    PaidAmount = VAT + TotalProductShipping + OverallTotalCost # OVERALL AMOUNT THE USER NEEDS TO PAY IS CALCULATED HERE, ROUNDED BY 2
    PaidAmount = round(PaidAmount, 2)

    # EVERY PRODUCT'S ORDER NUMBER, PRICE, OVERALL COSTS, PRODUCT SHIPPING, VAT AND THE PAYING AMOUNT ARE ALL DATA CONVERTED TO A STRING AND WHEN APPROPRIATE, A POUND SYMBOL IS CONCATENATED TO THE PRICE
    FRONTRiceMachineOrders = str(RiceMachineOrders)
    FRONTTotalRiceMachinePrice = str(TotalRiceMachinePrice)
    FRONTTotalRiceMachinePrice = ("£" + FRONTTotalRiceMachinePrice)
    FRONTTheBuffaloOrders = str(TheBuffaloOrders)
    FRONTTotalTheBuffaloPrice = str(TotalTheBuffaloPrice)
    FRONTTotalTheBuffaloPrice = ("£" + FRONTTotalTheBuffaloPrice)
    FRONTUncleJohnOrders = str(UncleJohnOrders)
    FRONTTotalUncleJohnPrice = str(TotalUncleJohnPrice)
    FRONTTotalUncleJohnPrice = ("£" + FRONTTotalUncleJohnPrice)
    FRONTRiceDiceOrders = str(RiceDiceOrders)
    FRONTTotalRiceDicePrice = str(TotalRiceDicePrice)
    FRONTTotalRiceDicePrice = ("£" + FRONTTotalRiceDicePrice)
    FRONTBasmatiBoilerOrders = str(BasmatiBoilerOrders)
    FRONTTotalBasmatiBoilerPrice = str(TotalBasmatiBoilerPrice)
    FRONTTotalBasmatiBoilerPrice = ("£" + FRONTTotalBasmatiBoilerPrice)
    FRONTCooker3000Orders = str(Cooker3000Orders)
    FRONTTotalCooker3000Price = str(TotalCooker3000Price)
    FRONTTotalCooker3000Price = ("£" + FRONTTotalCooker3000Price)
    FRONTOverallTotalCost = str(OverallTotalCost)
    FRONTOverallTotalCost = ("£" + FRONTOverallTotalCost)
    FRONTTotalProductShipping = str(TotalProductShipping)
    FRONTTotalProductShipping = ("£" + FRONTTotalProductShipping)
    FRONTVAT = str(VAT)
    FRONTVAT = ("£" + FRONTVAT)
    FRONTPaidAmount = str(PaidAmount)
    FRONTPaidAmount = ("£" + FRONTPaidAmount)
        
    # PAYING FOR THE PRODUCTS 

    # DISCOUNTS

    if request.method == "POST" and "OFFERCODE" in request.form: # CHECKING IF THE USER TYPED IN A DISCOUNT CODE
      InputtedDiscount = request.form["OFFERCODE"] # RECEIVING THE DISCOUNT CODE THE USER TYPED IN

      DiscountList = [] # AN ARRAY TO HOLD ALL OF THE DISCOUNTS IS CREATED

      cursor.execute("SELECT DiscountName FROM tblDiscounts") # RECEIVING ALL OF THE DISCOUNT CODES AND APPENDING IT TO THIS ARRAY
      for x in cursor.fetchall():
        DiscountList.append(x[0])

      global DiscountUsed # DISCOUNT USED IS GLOBALISED

      if InputtedDiscount in DiscountList: # CHECKING IF THE DISCOUNT THAT THE USER TYPED IN IS IN THE LIST
        cursor.execute("SELECT DiscountPercentage FROM tblDiscounts WHERE Discountname=?", (InputtedDiscount,))
        for x in cursor.fetchall():
          Percentage = x[0] # IF IT IS, RECEIVE THE PERCENTAGE OF THE DISCOUNT INTO THE VARIABLE PERCENTAGE

        Percentage = Percentage / 100 # DIVIDE IT BY 100 AND MULTIPLY IT TO THE OVERALL COST TO APPLY THE DISCOUNT
        DiscountCost = OverallTotalCost * Percentage

        OriginalCost = round(OverallTotalCost, 2) # ROUND THE OG AND DISCOUNT COSTS BY 2 DECIMALS AND DATA CONVERT IT INTO A STRING
        DiscountAdded = round(DiscountCost, 2)
        OriginalCost = str(OriginalCost)
        DiscountAdded = str(DiscountAdded)

        DiscountOverallTotalCost = OverallTotalCost # MAKE THIS EQUAL TO THE TOTAL COSTS OF THE ORDER AND THEN APPLY THE DISCOUNT COST
        DiscountOverallTotalCost -= DiscountCost

        FinalCost = round(DiscountOverallTotalCost, 2) # ROUND UP THE DISCOUNTED TOTAL COST AND CONVERT IT INTO A STRING
        FinalCost = str(FinalCost)

        FRONTOverallTotalCost = ("£" + OriginalCost + " - " + "£" + DiscountAdded + " = " + "£" + FinalCost) # CONCATENATE SO IT SHOWS THE DISCOUNT APPLIED

        DiscountCost = round(DiscountCost, 2) # ROUND THE COSTS OF THE DISCOUNT BY 2
        DiscountOverallTotalCost = round(DiscountOverallTotalCost, 2) # ROUND THE COSTS OF THE DISCOUNTED TOTAL COST BY 2

        global DiscountOverallTotalCostUsed # GLOBALISE THE VARIABLE DISCOUNT TOTAL COST, MAKE IT EQUAL TO DISCOUNT TOTAL COST USED
        DiscountOverallTotalCostUsed = DiscountOverallTotalCost

        VAT = DiscountOverallTotalCostUsed + TotalProductShipping # CREATE VAT BY ADDING SHIPPING AND DISCOUNTED COSTS, ROUND TO 2 DECIMALS
        VAT = round(VAT, 2)
        VAT = VAT * 0.2 # MULTIPLY IT BY 0.2 AND GLOBALISE DISCOUNT VAT, WHICH IS VAT ROUNDED BY 2

        global DiscountVAT
        DiscountVAT = round(VAT, 2)

        PaidAmount = DiscountVAT + TotalProductShipping + DiscountOverallTotalCost # CALCULATE AMOUNT THAT THE USER NEEDS TO PAY
        
        global DiscountPaidAmount # GLOBALISE THE OVERALL PAID AMOUNT BUT WITH THE DISCOUNT INCLUDED AND ROUND IT BY 2 DECIMAL PLACES
        DiscountPaidAmount = round(PaidAmount, 2)

        FRONTVAT = str(DiscountVAT) # DATA CONVERT THE VAT INTO A STRING AND CONCATENATE THE £ POUND SYMBOL
        FRONTVAT = ("£" + FRONTVAT)
        FRONTPaidAmount = str(DiscountPaidAmount) # DATA CONVERT THE OVERALL PAID AMOUNT TO A STRING AND CONCATENATE THE £ POUND SYMBOL
        FRONTPaidAmount = ("£" + FRONTPaidAmount)

        DiscountUsed += 1 # INCREMENT THE VARIABLE DISCOUNT USED BY 1

        return render_template("PaymentPage.html", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount) # SEND BACK THE PAYMENT PAGE WITH THE DISCOUNT APPLIED TO THEIR EXPENSES

      else:
        DiscountUsed = 0 # IF DISCOUNT DIDN'T EXISTED, DISCOUNT USED IS SET TO 0
        
        return render_template("PaymentPage.html", DISCOUNT="Not a valid discount code.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount) # SEND BACK THE PAYMENT PAGE, WITH THE ERROR MESSAGE THAT THE DISCOUNT ISN'T VALID

    # DISCOUNT

    # PAYING FOR THE PRODUCTS
    elif request.method == "POST" and ("PAYMENTTYPE" in request.form or "CARDNUMBER" in request.form or "POSTCODE" in request.form or "EXPIRATION" in request.form):
      # CHECK IF THE USER HAS TYPED IN THEIR PAYMENT TYPE, CARD NUMBER, POST CODE AND CARD EXPIRATION DATE
      AllPaymentDetails = request.form.to_dict("PAYMENTOPTIONS") # PUT ALL OF THE PAYMENT DETAILS INTO THIS DICTIONARY AND ASSIGN EACH VARIABLE THEIR RESPECTIVE DETAIL
      PaymentChoice = AllPaymentDetails['PAYMENTTYPE']
      UserCardNumber = AllPaymentDetails['CARDNUMBER']
      UserPostCode = AllPaymentDetails['POSTCODE']
      UserCardExpiration = AllPaymentDetails['EXPIRATION']

      if PaymentChoice == "MasterCard" or PaymentChoice == "ApplePay" or PaymentChoice == "PayPal":
        pass # CHECK IF THEY CHOSE A PAYMENT CHOICE

      else: # IF NOT RETURN THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THE USER NEEDS TO CHOOSE A PAYMENT OPTION
        return render_template("PaymentPage.html", ErrorMessage="Please choose a payment option.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)

      if len(UserCardNumber) == 16:
        pass # CHECK IF THEIR CARD NUYMBER IS 16 DIGITS LONG

      else: # ELSE SEND BACK THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEY NEED TO TYPE IN THEIR CARD NUMBER
        return render_template("PaymentPage.html", ErrorMessage="Please type in your card number.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)      

      #pattern = "[a-zA-Z]{1,2}[0-9R][0-9a-zA-Z]?[0-9][a-zA-Z]{2}" # RE PATTERN TO VALIDIFY THEIR POST CODE
      pattern = "^[a-zA-Z]{1,2}\d[a-zA-Z\d]?\s?\d[a-zA-Z]{2}$"
      if (re.search(pattern, UserPostCode)):
        pass # IF THEIR POST CODE MATCHES THE PATTERN, IT'S FINE

      else: # ELSE RETURN THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEY NEED TO TYPE IN A CORRECT POST CODE
        return render_template("PaymentPage.html", ErrorMessage="Please type in a correct post code.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)   

      if len(UserCardExpiration) == 0:
        return render_template("PaymentPage.html", ErrorMessage="Please enter an expiration date.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)

      else:
        pass
        
      TodayDate = date.today() # ESTABLISH TODAY'S DATE TO THIS VARIABLE AND CONVERT IT INTO A STRING, SAME WITH THE USER'S CARD EXPIRATION DATE

      TodayDate = str(TodayDate)
      UserCardExpiration = str(UserCardExpiration)

      TodayDateData = datetime.datetime.strptime(TodayDate, "%Y-%m-%d") # PUT TODAY'S AND THE EXPIRATION DATE INTO A YEAR, MONTH, DAY ORDER
      GivenDateData = datetime.datetime.strptime(UserCardExpiration, "%Y-%m-%d")

      TodayDay = TodayDateData.day # PUT'S TODAY'S DAY, MONTH AND YEAR INTO THEIR OWN VARIABLE
      TodayMonth = TodayDateData.month
      TodayYear = TodayDateData.year

      GivenDay = GivenDateData.day # PUT'S THE EXPIRATION DATE INTO DAY, MONTH AND YEAR INTO THEIR OWN VARIABLE
      GivenMonth = GivenDateData.month
      GivenYear = GivenDateData.year

      TodayDay = int(TodayDay) # DATA CONVERT ALL OF THE DAYS, MONTHS AND YEARS INTO INTEGERS
      TodayMonth = int(TodayMonth)
      TodayYear = int(TodayYear)
      GivenDay = int(GivenDay)
      GivenMonth = int(GivenMonth)
      GivenYear = int(GivenYear)

      if int(TodayYear) < int(GivenYear):
        # IF TODAY'S YEAR IS LESS THAN THE EXPIRATION YEAR, CARD IS VALID
        pass

      elif int(TodayYear) > int(GivenYear): # ELSE IF ITS OPPOSITE, SEND BACK THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEIR CARD IS EXPIRED
        return render_template("PaymentPage.html", ErrorMessage="Your card is expired.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)  

      elif int(TodayMonth) < int(GivenMonth):
        # IF TODAY'S MONTH IS LESS THAN THE EXPIRATION MONTH, CARD IS VALID
        pass

      elif int(TodayMonth) > int(GivenMonth): # ELSE IF IT'S OPPOSITE, SEND BACK THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEIR CARD IS EXPIRED
        return render_template("PaymentPage.html", ErrorMessage="Your card is expired.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)  

      elif int(TodayDay) < int(GivenDay):
        # IF TODAY'S DAY IS LESS THAN THE EXPIRATION DAY, CARD IS VALID
        pass

      elif int(TodayDay) > int(GivenDay): # ELSE IF IT'S OPPOSITE, SEND BACK THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEIR CARD IS EXPIRED
        return render_template("PaymentPage.html", ErrorMessage="Your card is expired.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)  

      else: # ELSE, JUST SEND BACK THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THEIR CARD IS EXPIRED
        return render_template("PaymentPage.html", ErrorMessage="Your card is expired.", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)  

      # IF ALL OF THE PAYMENT DETAILS ARE VERIFIED, DATA CONVERT THEM ALL INTO A STRING
      PaymentChoice = str(PaymentChoice)
      UserCardNumber = int(UserCardNumber)
      UserPostCode = str(UserPostCode)
      UserCardExpiration = str(UserCardExpiration)

      cursor.execute("INSERT INTO tblPaymentDetails (PaymentChoice, CardNumber, PostCode, ExpirationDate) VALUES (?, ?, ?, ?)", (PaymentChoice, UserCardNumber, UserPostCode, UserCardExpiration)) # INSERT ALL OF THEIR DETAILS INTO TBLPAYMENTDETAILS AND COMMIT IT TO THE DATABASE
      db.commit()

      UnitsSold = RiceMachineOrders + TheBuffaloOrders + UncleJohnOrders + RiceDiceOrders + BasmatiBoilerOrders + Cooker3000Orders
      # CALCULATE UNITS SOLD BY ADDING ALL OF THEIR ORDERS TOGETHER
      if DiscountUsed >= 1: # IF THEY USED A DISCOUNT, PUT IN THE DISCOUNTED COSTS AND COMMIT TO DATABASE, FOR TABLE FINANCIAL DETAILS
        cursor.execute("INSERT INTO tblFinancialDetails (TotalRevenue, VAT, ShippingCosts, SalesCosts, UnitsSold, TheRiceMachine, TheBuffalo, TheUncleJohn, RiceAndDice, TheBasmatiBoiler, RiceCooker3000) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", (DiscountPaidAmount, DiscountVAT, TotalProductShipping, DiscountOverallTotalCostUsed, UnitsSold, RiceMachineOrders, TheBuffaloOrders, UncleJohnOrders, RiceDiceOrders, BasmatiBoilerOrders, Cooker3000Orders))
        db.commit()

      else: # ELSE, INSERT THE REGULAR COSTS THEY HAD TO PAY, AND COMMIT TO DATABASE FOR TABLE FINANCIAL DETAILS
        cursor.execute("INSERT INTO tblFinancialDetails (TotalRevenue, VAT, ShippingCosts, SalesCosts, UnitsSold, TheRiceMachine, TheBuffalo, TheUncleJohn, RiceAndDice, TheBasmatiBoiler, RiceCooker3000) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", (PaidAmount, VAT, TotalProductShipping, OverallTotalCost, UnitsSold, RiceMachineOrders, TheBuffaloOrders, UncleJohnOrders, RiceDiceOrders, BasmatiBoilerOrders, Cooker3000Orders))
        db.commit()

      cursor.execute("DELETE FROM tblAddToCart WHERE Email=?", (UserEmail, ))
      db.commit() # DELETE THEIR SHOPPING CART AND COMMIT IT TO THE DATABASE

      return render_template("PaymentPage.html", ErrorMessage="Payment successful.", RiceMachineUnits=0, RiceMachinePrice="£0.0", BuffaloUnits=0, BuffaloPrice="£0.0", UncleJohnUnits=0, UncleJohnPrice="£0.0", RiceAndDiceUnits=0, RiceAndDicePrice="£0.0", BasmatiBoilerUnits=0, BasmatiBoilerPrice="£0.0", RiceCookerUnits=0, RiceCookerPrice="£0.0", TOTAL="£0.0", SHIPPING="£0.0", VAT="£0.0", PAIDAMOUNT="£0.0") # RETURN THE PAYMENT PAGE WITH THE MESSAGE THAT THE PAYMENT WAS SUCCESSFUL
      
    else: # ELSE, JUST SEND THE REGULAR PAYMENT PAGE IF THE USER ISN'T USING A DISCOUNT OR PAYING THEIR PRODUCTS YET
      return render_template("PaymentPage.html", RiceMachineUnits=FRONTRiceMachineOrders, RiceMachinePrice=FRONTTotalRiceMachinePrice, BuffaloUnits=FRONTTheBuffaloOrders, BuffaloPrice=FRONTTotalTheBuffaloPrice, UncleJohnUnits=FRONTUncleJohnOrders, UncleJohnPrice=FRONTTotalUncleJohnPrice, RiceAndDiceUnits=FRONTRiceDiceOrders, RiceAndDicePrice=FRONTTotalRiceDicePrice, BasmatiBoilerUnits=FRONTBasmatiBoilerOrders, BasmatiBoilerPrice=FRONTTotalBasmatiBoilerPrice, RiceCookerUnits=FRONTCooker3000Orders, RiceCookerPrice=FRONTTotalCooker3000Price, TOTAL=FRONTOverallTotalCost, SHIPPING=FRONTTotalProductShipping, VAT=FRONTVAT, PAIDAMOUNT=FRONTPaidAmount)

  else: # ELSE SEND THE PAYMENT PAGE WITH THE ERROR MESSAGE THAT THE USER NEED TO LOGIN TO BE ABLE TO PURCHASE ANYTHING
    return render_template("PaymentPage.html", ErrorMessage="You'll need to login to purchase anything", RiceMachineUnits=0, RiceMachinePrice="£0.0", BuffaloUnits=0, BuffaloPrice="£0.0", UncleJohnUnits=0, UncleJohnPrice="£0.0", RiceAndDiceUnits=0, RiceAndDicePrice="£0.0", BasmatiBoilerUnits=0, BasmatiBoilerPrice="£0.0", RiceCookerUnits=0, RiceCookerPrice="£0.0", TOTAL="£0.0", SHIPPING="£0.0", VAT="£0.0", PAIDAMOUNT="£0.0")

  # ELSE JUST SEND THE USER THE DEFAULT PAYMENT PAGE
  return render_template("PaymentPage.html")
# [===] PAYMENT PAGE [===] #

# [===] ADMIN ANALYSIS PAGE [===] #
@app.route("/AdminAnalysis", methods=["POST", "GET"]) # ESTABLISHING AN APP ROUTE TO ACCEPT BOTH POST AND GET REQUESTS, ALONGSIDE SUBROUTINE CREATED
def AdminAnalysis():
  InformationList = [] # ARRAY CREATED TO STORE BUSINESS INFORMATION

  # USING SQL, SELECTING ALL OF THE INFORMATION NEEDED TO SHOW TO ADMINS TO THE FRONTEND, APPENDED TO THE INFORMATION ARRAY
  cursor.execute(""" 
  SELECT COUNT(PurchaseID), SUM(UnitsSold), SUM(TotalRevenue), SUM(VAT), SUM(ShippingCosts), SUM(SalesCosts), SUM(TheRiceMachine), SUM(TheBuffalo), SUM(TheUncleJohn), SUM(RiceAndDice), SUM(TheBasmatiBoiler), SUM(RiceCooker3000) FROM tblFinancialDetails
  """)
  for x in cursor.fetchall():
    InformationList.append(x)

  InformationList1 = InformationList[0] # MAKING INFORMATION LIST FROM 2D TO 1D ARRAY
  NumberOfPurchases = InformationList1[0] # INDEXING ALL OF THE INFORMATION TO THEIR RESPECTIVE VARIABLE
  TotalUnitsSold = InformationList1[1]
  TotalRevenue = InformationList1[2]
  TotalVAT = InformationList1[3]
  TotalShipping = InformationList1[4]
  TotalSalesCosts = InformationList1[5]
  TotalRiceMachines = InformationList1[6]
  TotalBuffalos = InformationList1[7]
  TotalUncleJohns = InformationList1[8]
  TotalRiceAndDice = InformationList1[9]
  TotalBasmatiBoilers = InformationList1[10]
  TotalRiceCookers = InformationList1[11]

  # BUBBLE SORT TO MAKE ALL OF THE PRODUCTS IN ORDER OF POPULARITY, AKA WHICH IS BOUGHT FREQUENTLY AND WHICH IS NOT
  def BubbleSort(Array): # SUBROUTINE CREATED FOR THIS, DATA IS THE ARRAY OF PRODUCTS
    for i in range(len(Array)): # IS A FOR LOOP, GOING THROUGH THE ENTIRE THING FOR ALL OF THE ELEMENTS INSIDE
      for j in range (0, len(Array) - i - 1): # THIS FOR LOOP HERE IS SO WE CAN SWAP AROUND 2 ELEMENTS WHEN NECESSARY, THEN GOING BACK TO THE OTHER FOR LOOP TO CONTINUE TRAVERSING THROUGHOUT THE ARRAY
        if Array [j] > Array[j+1]: # IF THIS INDEX IS BIGGER THAN THE INDEX AHEAD, THAN TEMP IS EQUAL TO ARRAY INDEX J
          Temp = Array[j]
          Array[j] = Array[j+1] # WHERE ARRAY J IS NOW J+1, AKA IF J IS 10, AND J+1 WAS 8, IT'LL SWAP
          Array[j+1] = Temp # AND THEN J+1 WILL BECOME 10, AKA THE VARIABLE THAT IS TEMPORARILY STORING THE VALUE

  ProductPopularity = [] # AN ARRAY CALLED PRODUCT POPULARITY, WHICH IS THEN APPENDED ALL OF THE PRODUCTS TO THE ARRAY
  ProductPopularity.append(int(TotalRiceMachines))
  ProductPopularity.append(int(TotalBuffalos))
  ProductPopularity.append(int(TotalUncleJohns))
  ProductPopularity.append(int(TotalRiceAndDice))
  ProductPopularity.append(int(TotalBasmatiBoilers))
  ProductPopularity.append(int(TotalRiceCookers))
  BubbleSort(ProductPopularity) # BUBBLE SORTING THE ARRAY

  LeastPopularProduct = ProductPopularity[0] # LEAST AND MOST POPULAR PRODUCT IS INDEXED, FOR THE SMALLEST AND LARGEST VALUE
  MostPopularProduct = ProductPopularity[5]

  if int(TotalRiceMachines) == LeastPopularProduct: # SERIES OF IF STATEMENTS, THAT IF THE PRODUCT IS EQUAL TO THE SAME NUMBER OF LEAST POPULAR PRODUCT, THAT'S THE LEAST POPULAR PRODUCT
    LeastPopular = "The Rice Machine"
  elif int(TotalBuffalos) == LeastPopularProduct:
    LeastPopular = "The Buffalo"
  elif int(TotalUncleJohns) == LeastPopularProduct:
    LeastPopular = "The Uncle John"
  elif int(TotalRiceAndDice) == LeastPopularProduct:
    LeastPopular = "The Rice And Dice"
  elif int(TotalBasmatiBoilers) == LeastPopularProduct:
    LeastPopular = "The Basmati Boiler"
  else:
    LeastPopular = "The Rice Cooker 3000"
 
  if int(TotalRiceMachines) == MostPopularProduct: # SERIES OF IF STATEMENTS, THAT IF THE PRODUCT IS EQUAL TO THE SAME NUMBER OF MOST POPULAR PRODUCT, THAT'S THE MOST POPULAR PRODUCT
    MostPopular = "The Rice Machine"
  elif int(TotalBuffalos) == MostPopularProduct:
    MostPopular = "The Buffalo"
  elif int(TotalUncleJohns) == MostPopularProduct:
    MostPopular = "The Uncle John"
  elif int(TotalRiceAndDice) == MostPopularProduct:
    MostPopular = "The Rice And Dice"
  elif int(TotalBasmatiBoilers) == MostPopularProduct:
    MostPopular = "The Basmati Boiler"
  else:
    MostPopular = "The Rice Cooker 3000"

  # CALCULATING THE PERCENTAGE OF THE REVENUE WHICH IS VAT, SHIPPING COSTS AND SALES COSTS, VIA ARITHMETICS AND ROUNDING UP BY 2 DECIMAL PLACES
  VATPercentage = round(((TotalVAT / TotalRevenue) * 100), 2)
  ShippingPercentage = round(((TotalShipping / TotalRevenue) * 100), 2)
  SalesPercentage = round(((TotalSalesCosts / TotalRevenue) * 100), 2)

  # RETURN THE ADMIN ANALYSIS PAGE WITH ALL OF THE NECESSARY INFORMATION FOR THE ADMIN
  return render_template("AdminAnalysis.html", PurchasesNumber=str(NumberOfPurchases), TotalUnits=str(TotalUnitsSold), TotalRevenue=str(TotalRevenue), VATPercentage=str(VATPercentage), ShippingCostsPercentage=str(ShippingPercentage), SalesCostsPercentage=str(SalesPercentage), TOTALRiceMachine=str(TotalRiceMachines), TOTALBuffalo=str(TotalBuffalos), TOTALUncleJohn=str(TotalUncleJohns), TOTALRiceAndDice=str(TotalRiceAndDice), TOTALBasmatiBoiler=str(TotalBasmatiBoilers), TOTALRiceCooker=str(TotalRiceCookers), MostPopularProduct=MostPopular, LeastPopularProduct=LeastPopular)

# [===] ADMIN ANALYSIS PAGE [===] #

# [===] ADMIN INSIGHTS AND RECIPES PAGE [===] #
@app.route("/AdminInsightsAndRecipes", methods=["POST", "GET"]) # APP ROUTE CREATED TO ACCEPT BOTH POST AND GET REQUESTS, SUBROUTINE ESTABLISHED
def AdminInsightsAndRecipes():
  if request.method == "POST":                 # CHECKING IF THE METHOD IS POST, IF SO, RECEIVE THE TITLE AND BLOG FROM THE ADMIN, ASSIGN IT TO POSTTITLE AND POSTCONTENT
    PostTitle = request.form["TITLE"]
    PostContent = request.form["BLOG"]

    if PostTitle.isspace() or len(PostTitle) == 0: # SERIES OF IF STATEMENTS TO CHECK IF THE TITLE/CONTENT, IS EQUAL TO 0 OR JUST SPACE
      return render_template("AdminInsightsAndRecipes.html", ERRORMESSAGE="Please type in a title for the insight and recipe.")

    elif PostContent.isspace() or len(PostContent) == 0: # IF SO, IT'LL RETURN THE INSIGHTS AND RECIPES PAGE WITH THE ERROR MESSAGE THAT THEY NEEDED TO TYPE SOMETHING
      return render_template("AdminInsightsAndRecipes.html", ERRORMESSAGE="Please type in the content for the insight and recipe.")

    else: # ELSE, INSERT THE USER INPUTS INTO THE TABLE VIA SQL AND COMMIT IT TO THE DATABASE
      cursor.execute("INSERT INTO tblInsightsAndRecipes (Title, Content) VALUES (?, ?)", (PostTitle, PostContent))
      db.commit()

      return render_template("AdminInsightsAndRecipes.html", ERRORMESSAGE="Input successful.") # RETURN THE INSIGHTS AND RECIPES PAGE WITH THE MESSAGE THAT IT'S BEEN SUCCESSFUL
      
  else: # ELSE SEND THE ADMIN INSIGHTS AND RECIPES PAGE TO THE ADMIN, AWAITING FOR INPUTS
    return render_template("AdminInsightsAndRecipes.html")
# [===] ADMIN INSIGHTS AND RECIPES PAGE [===] #
        
# [===] THE SERVER [===] #
if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True, port="8080")
# [===] [===] #
